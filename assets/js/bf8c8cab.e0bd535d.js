"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[1168],{3905:(e,t,i)=>{i.d(t,{Zo:()=>u,kt:()=>d});var n=i(7294);function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){l(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,n,l=function(e,t){if(null==e)return{};var i,n,l={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(l[i]=e[i]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(l[i]=e[i])}return l}var c=n.createContext({}),s=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},u=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var i=e.components,l=e.mdxType,a=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=s(i),y=l,d=p["".concat(c,".").concat(y)]||p[y]||f[y]||a;return i?n.createElement(d,r(r({ref:t},u),{},{components:i})):n.createElement(d,r({ref:t},u))}));function d(e,t){var i=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=i.length,r=new Array(a);r[0]=y;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[p]="string"==typeof e?e:l,r[1]=o;for(var s=2;s<a;s++)r[s]=i[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}y.displayName="MDXCreateElement"},5418:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>s});var n=i(7462),l=(i(7294),i(3905));const a={sidebar_position:8},r="Concurrency",o={unversionedId:"features/concurrency",id:"features/concurrency",title:"Concurrency",description:"Activities can be executed in series or in parallel. In either case, you start by using ActivityStub::all() method to wait for a group of activities to complete in parallel.",source:"@site/docs/features/concurrency.md",sourceDirName:"features",slug:"/features/concurrency",permalink:"/docs/features/concurrency",draft:!1,editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/docs/features/concurrency.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Child Workflows",permalink:"/docs/features/child-workflows"},next:{title:"Sagas",permalink:"/docs/features/sagas"}},c={},s=[{value:"Series",id:"series",level:2},{value:"Parallel",id:"parallel",level:2},{value:"Mix and Match",id:"mix-and-match",level:2},{value:"Child Workflows in Parallel",id:"child-workflows-in-parallel",level:2}],u={toc:s};function p(e){let{components:t,...i}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"concurrency"},"Concurrency"),(0,l.kt)("p",null,"Activities can be executed in series or in parallel. In either case, you start by using ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityStub::make()")," to create a new instance of an activity and return a promise that represents the execution of that activity. The activity will immediately begin executing in the background. You can then ",(0,l.kt)("inlineCode",{parentName:"p"},"yield")," this promise to pause the execution of the workflow and wait for the result of the activity, or pass the promise into the ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityStub::all()")," method to wait for a group of activities to complete in parallel."),(0,l.kt)("h2",{id:"series"},"Series"),(0,l.kt)("p",null,"This example will execute 3 activities in series, waiting for the completion of each activity before continuing to the next one."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\Workflow;\n\nclass MyWorkflow extends Workflow\n{\n    public function execute()\n    {\n        return [\n            yield ActivityStub::make(MyActivity1::class),\n            yield ActivityStub::make(MyActivity1::class),\n            yield ActivityStub::make(MyActivity1::class),\n        ];\n    }\n}\n")),(0,l.kt)("h2",{id:"parallel"},"Parallel"),(0,l.kt)("p",null,"This example will execute 3 activities in parallel, waiting for the completion of all activities and collecting the results."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\Workflow;\n\nclass MyWorkflow extends Workflow\n{\n    public function execute()\n    {\n        return yield ActivityStub::all([\n            ActivityStub::make(MyActivity1::class),\n            ActivityStub::make(MyActivity2::class),\n            ActivityStub::make(MyActivity3::class),\n        ]);\n    }\n}\n")),(0,l.kt)("p",null,"The main difference between the serial example and the parallel execution example is the number of ",(0,l.kt)("inlineCode",{parentName:"p"},"yield")," statements. In the serial example, there are 3 ",(0,l.kt)("inlineCode",{parentName:"p"},"yield")," statements, one for each activity. This means that the workflow will pause and wait for each activity to complete before continuing to the next one. In the parallel example, there is only 1 ",(0,l.kt)("inlineCode",{parentName:"p"},"yield")," statement, which wraps all of the activities in a call to ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityStub::all()"),". This means that all of the activities will be executed in parallel, and the workflow will pause and wait for all of them to complete as a group before continuing."),(0,l.kt)("h2",{id:"mix-and-match"},"Mix and Match"),(0,l.kt)("p",null,"You can also mix serial and parallel executions as desired."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\Workflow;\n\nclass MyWorkflow extends Workflow\n{\n    public function execute()\n    {\n        return [\n            yield ActivityStub::make(MyActivity1::class),\n            yield ActivityStub::all([\n                ActivityStub::async(fn () => [\n                    yield ActivityStub::make(MyActivity2::class),\n                    yield ActivityStub::make(MyActivity3::class),\n                ]),\n                ActivityStub::make(MyActivity4::class),\n                ActivityStub::make(MyActivity5::class),\n            ]),\n            yield ActivityStub::make(MyActivity6::class),\n        ];\n    }\n}\n")),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://mermaid.ink/img/pako:eNp9kctugzAQRX8lmjUBbPOyK1WqlC6zalcVGwcbsAQYwRCVRvx7DZUS0UW88txzNc8bFFZpEFANsq8Pn6eXvDsczvNbgeZqcCbH4-sjos9g9AzGe0h3kO0h28FkD6NnMP4PwYNWD600yo14W805YK1bnYNwX6VLOTWYQ94tziontB9zV4DAYdIeTL2SqE9GuuW0IErZjHf1XRm0w11srFTahTfAud_2aUZ0KQvblaZa9WlonFwj9qMIghX7lcF6uviFbYPRqFoOWF95EiQ0ySRlOkmZjBlTxYXwrKQRKVUaEiphWTzoZfdl7aMrvfVz_jvmdtPNs1b-BhH7PORxxBNGGM1SHnkwg0iZHxFOU-YKxoxy6vL-bEmJH26POBxymvFk-QWh37PQ?type=png",alt:"workflow"})),(0,l.kt)("p",null,"Activity 1 will execute and complete before any other activities start. Activities 2 and 3 will execute in series, waiting for each to complete one after another before continuing. At the same time, activities 4 and 5 will execute together in parallel and only when they all complete will execution continue. Finally, activity 6 executes last after all others have completed."),(0,l.kt)("h2",{id:"child-workflows-in-parallel"},"Child Workflows in Parallel"),(0,l.kt)("p",null,"You can pass child workflows to ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityStub::all()")," along with with other activities (but we also provide ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildWorkflowStub::all()")," if you prefer). Both of these are just thin wrappers for React Promise's ",(0,l.kt)("inlineCode",{parentName:"p"},"all()"),". It works the same way as parallel activity execution, but for child workflows. It allows you to fan out multiple child workflows and wait for all of them to complete together."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\n\n$results = yield ChildWorkflowStub::all([\n    ChildWorkflowStub::make(ChildA::class),\n    ChildWorkflowStub::make(ChildB::class),\n    ChildWorkflowStub::make(ChildC::class),\n]);\n")),(0,l.kt)("p",null,"This makes it easy to build hierarchical parallelism into your workflows."))}p.isMDXComponent=!0}}]);