"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"waterline-ui","metadata":{"permalink":"/blog/waterline-ui","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-19-waterline-ui.md","source":"@site/blog/2022-11-19-waterline-ui.md","title":"Waterline: Elegant UI for Laravel Workflows","description":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!","date":"2022-11-19T00:00:00.000Z","formattedDate":"November 19, 2022","tags":[{"label":"ui","permalink":"/blog/tags/ui"},{"label":"horizon","permalink":"/blog/tags/horizon"},{"label":"queues","permalink":"/blog/tags/queues"},{"label":"workflows","permalink":"/blog/tags/workflows"}],"readingTime":1.645,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"waterline-ui","title":"Waterline: Elegant UI for Laravel Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["ui","horizon","queues","workflows"]},"nextItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"}},"content":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!\\n\\n![dashboard](https://miro.medium.com/max/1400/1*2FP4crjpM8C48kAnqAjv5A.webp)\\n\\nLook familiar? Yes, this is shamelessly based on Horizon! However, the similarity is only superficial. Waterline is geared towards workflows, not queues. In fact, Horizon is still the best way to monitor your queues and plays along nicely with it.\\n\\n> Waterline is to workflows what Horizon is to queues.\\n\\n![workflow view](https://miro.medium.com/max/1400/1*EKWNNFy6kYRrqMbaozA8IQ.webp)\\n\\nAt this point you can see a lot of differences! You can see the arguments passed to the workflow and the output from the completed workflow. You can see a timeline that shows each activity at a glance along with any exceptions that were thrown. There is also a list view for the activities and their results.\\n\\nAt the bottom are any exceptions thrown, including a stack trace and a snippet of code showing the exact line. This makes debugging a breeze.\\n\\nIf you\u2019re familiar with Horizon then installing Waterline will be like d\xe9j\xe0 vu but the setup is simpler because Waterline doesn\u2019t care about queues, only workflows.\\n\\n> This article is part of a series on [Larvel Workflow](https://github.com/laravel-workflow/laravel-workflow), a durable workflow engine that allows users to write long running persistent distributed workflows (orchestrations) in PHP powered by Laravel Queues. Inspired by Temporal and Azure Durable Functions.\\n\\n## Installation\\n\\nYou can find the official [documentation](https://github.com/laravel-workflow/waterline) here but setup is simple.\\n\\n```bash\\ncomposer require laravel-workflow/waterline  \\n  \\nphp artisan waterline:publish\\n```\\n\\nThat\u2019s it! Now you should be able to view the `/waterline` URL in your app. By default this URL is only available in local environments. To view this outside of local environments you will have to modify the `WaterlineServiceProvider`.\\n\\n```php\\nGate::define(\'viewWaterline\', function ($user) {  \\n    return in\\\\_array($user->email, \\\\[  \\n        \'admin@example.com\',  \\n    \\\\]);  \\n});\\n```\\n\\nThis will allow only the single admin user to access the Waterline UI.\\n\\nIf you want more context for the workflow that is show in the screenshot above, make sure to read my [previous article](https://medium.com/@laravel-workflow/email-verifications-using-laravel-workflow-acd6707aa7b3).\\n\\nThanks for reading!"},{"id":"invalidating-cloud-images","metadata":{"permalink":"/blog/invalidating-cloud-images","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-15-invalidating-cloud-images.md","source":"@site/blog/2022-11-15-invalidating-cloud-images.md","title":"Invalidating Cloud Images in Laravel with Workflows","description":"Many services like Cloud Image offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.","date":"2022-11-15T00:00:00.000Z","formattedDate":"November 15, 2022","tags":[{"label":"cache","permalink":"/blog/tags/cache"},{"label":"invalidation","permalink":"/blog/tags/invalidation"},{"label":"cloud","permalink":"/blog/tags/cloud"},{"label":"images","permalink":"/blog/tags/images"}],"readingTime":3.07,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"invalidating-cloud-images","title":"Invalidating Cloud Images in Laravel with Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["cache","invalidation","cloud","images"]},"prevItem":{"title":"Waterline: Elegant UI for Laravel Workflows","permalink":"/blog/waterline-ui"},"nextItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"Many services like [Cloud Image](https://docs.cloudimage.io/go/cloudimage-documentation-v7/en/caching-acceleration/invalidation-api) offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.\\n\\nHowever, it can be challenging if you want to automate this and also ensure that the image has been invalidated. This is because most invalidation APIs are asynchronous. When you request an image to be cleared from the cache, the API will return a response immediately. Then the actual process to clear the image from the cache runs in the background, sometimes taking up to 30 seconds before the image is updated. You could simply trust that the process works but it is also possible to be 100% sure with an automated workflow.\\n\\n> This article is part of a series on [Larvel Workflow](https://github.com/laravel-workflow/laravel-workflow), a durable workflow engine that allows users to write long running persistent distributed workflows (orchestrations) in PHP powered by Laravel Queues. Inspired by Temporal and Azure Durable Functions.\\n\\nThe workflow we need to write is as follows:\\n\\n1.  Check the currently cached image\u2019s timestamp via HEAD call\\n2.  Invalidate cached image via API call\\n3.  Check if the image timestamp has changed\\n4.  If not, wait a while and check again\\n5.  After 3 failed checks, go back to step 2\\n\\nThe workflow consists of two activities. The first activity gets the current timestamp of the image. This timestamp is used to determine if the image was actually cleared from the cache or not.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass CheckImageDateActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        return Http::head(\'https://\' . config(\'services.cloudimage.token\') . \'.cloudimg.io/\' . $url)\\n            ->header(\'date\');\\n    }\\n}\\n```\\n\\nThe second activity makes the actual call to Cloud Image\u2019s API to invalidate the image from the cache.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass InvalidateCacheActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        Http::withHeaders([\\n            \'X-Client-key\' => config(\'services.cloudimage.key\'),\\n            \'Content-Type\' => \'application/json\'\\n        ])->post(\'https://api.cloudimage.com/invalidate\', [\\n            \'scope\' => \'original\',\\n            \'urls\' => [\\n                \'/\' . $url\\n            ],\\n        ]);\\n    }\\n}\\n```\\n\\nThe workflow looks as follows and is the same process as outlined before.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass InvalidateCacheWorkflow extends Workflow\\n{\\n    public function execute($url)\\n    {\\n        $oldDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n        while (true) {\\n            yield ActivityStub::make(InvalidateCacheActivity::class, $url);\\n\\n            for ($i = 0; $i < 3; ++$i) { \\n                yield WorkflowStub::timer(30);\\n\\n                $newDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n                if ($oldDate !== $newDate) return;    \\n            }\\n        }\\n    }\\n}\\n```\\n\\nLine 13 uses an activity to get the current timestamp of the image we want to invalidate from the cache.\\n\\nLine 15 starts a loop that only exits when the image timestamp has changed.\\n\\nLine 16 uses an activity to invalidate the image from the cache.\\n\\nLine 18 starts a loop that tries a maximum of three times to first sleep and then check if the image timestamp has change, after three times the loop restarts at line 15.\\n\\nLine 19 sleeps the workflow for 30 seconds. This gives Cloud Image time to clear the image from their cache before checking the timestamp again.\\n\\nLines 21\u201323 reuse the activity from earlier to get the current timestamp of the cached image and compare it to the one saved on line 13. If the timestamps don\u2019t match then the image has successfully been cleared from the cache and we can exit the workflow. Otherwise, after three attempts, we start the process over again.\\n\\nThis is how the workflow execution looks in the queue assuming no retries are needed.\\n\\n![workflow execution](https://miro.medium.com/max/1400/1*7psZLD9mKGJnzEw508oIAw.webp)\\n\\nThe added benefit is that your image is now cached again and will be fast for the next user! Thanks for reading!"},{"id":"converting-videos-with-ffmpeg","metadata":{"permalink":"/blog/converting-videos-with-ffmpeg","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-31-converting-videos-with-ffmpeg.md","source":"@site/blog/2022-10-31-converting-videos-with-ffmpeg.md","title":"Converting Videos with FFmpeg and Laravel Workflow","description":"FFmpeg is a free, open-source software project allowing you to record, convert and stream audio and video.","date":"2022-10-31T00:00:00.000Z","formattedDate":"October 31, 2022","tags":[{"label":"video","permalink":"/blog/tags/video"},{"label":"ffmpeg","permalink":"/blog/tags/ffmpeg"},{"label":"conversion","permalink":"/blog/tags/conversion"},{"label":"transcoding","permalink":"/blog/tags/transcoding"}],"readingTime":1.67,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"converting-videos-with-ffmpeg","title":"Converting Videos with FFmpeg and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["video","ffmpeg","conversion","transcoding"]},"prevItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"},"nextItem":{"title":"Email Verifications Using Laravel Workflow","permalink":"/blog/email-verifications"}},"content":"[FFmpeg](https://ffmpeg.org/) is a free, open-source software project allowing you to record, convert and stream audio and video.\\n\\n[Laravel Queues](https://laravel.com/docs/9.x/queues) are great for long running tasks. Converting video takes a long time! With [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow), you can harness the power of queues to convert videos in the background and easily manage the process.\\n\\nRequirements\\n============\\n\\n1.  You\u2019ll need to [install FFmpeg](https://ffmpeg.org/download.html)\\n2.  Then `composer require php-ffmpeg/php-ffmpeg` ([docs](https://github.com/PHP-FFMpeg/PHP-FFMpeg#readme))\\n3.  Finally `composer require laravel-workflow/laravel-workflow` ([docs](https://github.com/laravel-workflow/laravel-workflow#laravel-workflow-))\\n\\nWorkflow\\n========\\n\\nA workflow is an easy way to orchestrate activities. A workflow that converts a video from one format to another might have several activities, such as downloading the video from storage, the actual conversion, and then finally notifying the user that it\u2019s finished.\\n\\nFor simplicity, the workflow we are making today will only contain the most interesting activity, converting the video.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass ConvertVideoWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        yield ActivityStub::make(\\n            ConvertVideoWebmActivity::class,\\n            storage_path(\'app/oceans.mp4\'),\\n            storage_path(\'app/oceans.webm\'),\\n        );\\n    }\\n}\\n```\\n\\nWe need a video to convert. We can use this one:\\n\\n[http://vjs.zencdn.net/v/oceans.mp4](http://vjs.zencdn.net/v/oceans.mp4)\\n\\nDownload it and save it to your app storage folder.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse FFMpeg\\\\FFMpeg;\\nuse FFMpeg\\\\Format\\\\Video\\\\WebM;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertVideoWebmActivity extends Activity\\n{\\n    public $timeout = 5;\\n\\n    public function execute($input, $output)\\n    {\\n        $ffmpeg = FFMpeg::create();\\n        $video = $ffmpeg->open($input);\\n        $format = new WebM();\\n        $format->on(\'progress\', fn () => $this->heartbeat());\\n        $video->save($format, $output);\\n    }\\n}\\n```\\n\\nThe activity converts any input video into a [WebM](https://www.webmproject.org/) output video. While ffmpeg is converting the video, a progress callback is triggered which in turn heartbeats the activity.\\n\\nThis is necessary because we have set a reasonable timeout of 5 seconds but we also have no idea how long it will take to convert the video. As long as we send a heartbeat at least once every 5 seconds, the activity will not timeout.\\n\\n![heartbeat](https://miro.medium.com/max/1400/1*ccrxeOEZYQciDYEprRKWiQ.webp)\\n\\n![no heartbeat](https://miro.medium.com/max/1400/1*9ZF3LTqjf4qsVcNVX5LK0A.webp)\\n\\nWithout a heartbeat, the worker will be killed after the timeout of 5 seconds is reached.\\n\\nTo actually run the workflow you just need to call:\\n\\n```php\\nWorkflowStub::make(ConvertVideoWorkflow::class)->start();\\n```\\n\\nAnd that\u2019s it!"},{"id":"email-verifications","metadata":{"permalink":"/blog/email-verifications","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-29-email-verifications.md","source":"@site/blog/2022-10-29-email-verifications.md","title":"Email Verifications Using Laravel Workflow","description":"A typical registration process goes as follows:","date":"2022-10-29T00:00:00.000Z","formattedDate":"October 29, 2022","tags":[{"label":"emails","permalink":"/blog/tags/emails"},{"label":"verification","permalink":"/blog/tags/verification"},{"label":"signed-urls","permalink":"/blog/tags/signed-urls"}],"readingTime":4.42,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"email-verifications","title":"Email Verifications Using Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["emails","verification","signed-urls"]},"prevItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"A typical registration process goes as follows:\\n\\n1.  User fills out registration form and submits it\\n2.  Laravel creates user in database with null `email_verified_at`\\n3.  Laravel sends email with a code, or a link back to our website\\n4.  User enters code, or clicks link\\n5.  Laravel sets `email_verified_at` to the current time\\n\\nWhat\u2019s wrong with this? Nothing. But like all things, as soon as real world complexity creeps in, this pattern could become painful. What if you wanted to send an email after the code or link expires? And do you really need a user in your database if they never verify their email address?\\n\\nLet\u2019s take this trivial example and replace it with a workflow. This is based on the [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library.\\n\\nGet Started\\n===========\\n\\nCreate a standard Laravel application and create the following files. First, the API routes.\\n\\n```php\\nuse App\\\\Workflows\\\\VerifyEmail\\\\VerifyEmailWorkflow;\\nuse Illuminate\\\\Support\\\\Facades\\\\Hash;\\nuse Illuminate\\\\Support\\\\Facades\\\\Route;\\nuse Workflow\\\\WorkflowStub;\\n\\nRoute::get(\'/register\', function () {\\n    $workflow = WorkflowStub::make(VerifyEmailWorkflow::class);\\n\\n    $workflow->start(\\n        \'test+1@example.com\',\\n        Hash::make(\'password\'),\\n    );\\n\\n    return response()->json([\\n        \'workflow_id\' => $workflow->id(),\\n    ]);\\n});\\n\\nRoute::get(\'/verify-email\', function () {\\n    $workflow = WorkflowStub::load(request(\'workflow_id\'));\\n\\n    $workflow->verify();\\n\\n    return response()->json(\'ok\');\\n})->name(\'verify-email\');\\n```\\n\\nThe `register` route creates a new `VerifyEmailWorkflow` , passes in the email and password, and then starts the workflow. Notice that we hash the password before giving it to the workflow. This prevents the plain text from being stored in the workflow logs.\\n\\nThe `verify-email` route receives a workflow id, loads it and then calls the `verify()` signal method.\\n\\nNow let\u2019s take a look at the actual workflow.\\n\\n```php\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\SignalMethod;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass VerifyEmailWorkflow extends Workflow\\n{\\n    private bool $verified = false;\\n\\n    #[SignalMethod]\\n    public function verify()\\n    {\\n        $this->verified = true;\\n    }\\n\\n    public function execute($email = \'\', $password = \'\')\\n    {\\n        yield ActivityStub::make(SendEmailVerificationEmailActivity::class, $email);\\n\\n        yield WorkflowStub::await(fn () => $this->verified);\\n\\n        yield ActivityStub::make(VerifyEmailActivity::class, $email, $password);\\n    }\\n}\\n```\\n\\nTake notice of the `yield` keywords. Because PHP (and most other languages) cannot save their execution state, coroutines rather than normal functions are used inside of workflows (but not activities). A coroutine will be called multiple times in order to execute to completion.\\n\\n![graph](https://miro.medium.com/max/1400/1*6eE2Gll61IbAAU85Md75OQ.webp)\\n\\nEven though this workflow will execute to completion effectively once, it will still be partially executed four different times. The results of activities are cached so that only failed activities will be called again. Successful activities get skipped.\\n\\nBut notice that any code we write between these calls will be called multiple times. That\u2019s why your code needs to be **deterministic** inside of workflow methods! If your code has four executions, each at different times, they must still all behave the same. There are no such limitations within activity methods.\\n\\nStep By Step\\n============\\n\\nThe first time the workflow executes, it will reach the call to `SendEmailVerificationEmailActivity` , start that activity, and then exit. Workflows suspend execution while an activity is running. After the `SendEmailVerificationEmailActivity` finishes, it will resume execution of the workflow. This brings us to\u2026\\n\\nThe second time the workflow is executed, it will reach the call to `SendEmailVerificationEmailActivity` and skip it because it will already have the result of that activity. Then it will reach the call to `WorkflowStub::await()` which allows the workflow to wait for an external signal. In this case, it will come from the user clicking on the verification link they receive in their email. Once the workflow is signaled then it will execute for\u2026\\n\\nThe third time, both the calls to `SendEmailVerificationEmailActivity` and `WorkflowStub::await()` are skipped. This means that the `VerifyEmailActivity` will be started. After the final activity has executed we still have\u2026\\n\\nThe final time the workflow is called, there is nothing left to do so the workflow completes.\\n\\nNow let\u2019s take a look at the activities.\\n\\nThe first activity just sends the user an email.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Mail\\\\VerifyEmail;\\nuse Illuminate\\\\Support\\\\Facades\\\\Mail;\\nuse Workflow\\\\Activity;\\n\\nclass SendEmailVerificationEmailActivity extends Activity\\n{\\n    public function execute($email)\\n    {\\n        Mail::to($email)->send(new VerifyEmail($this->workflowId()));\\n    }\\n}\\n```\\n\\nThe email contains a temporary signed URL that includes the workflow ID.\\n\\n```php\\nnamespace App\\\\Mail;\\n\\nuse Illuminate\\\\Bus\\\\Queueable;\\nuse Illuminate\\\\Mail\\\\Mailable;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Content;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Envelope;\\nuse Illuminate\\\\Queue\\\\SerializesModels;\\nuse Illuminate\\\\Support\\\\Facades\\\\URL;\\n\\nclass VerifyEmail extends Mailable\\n{\\n    use Queueable, SerializesModels;\\n\\n    private $workflowId;\\n\\n    public function __construct($workflowId)\\n    {\\n        $this->workflowId = $workflowId;\\n    }\\n\\n    public function envelope()\\n    {\\n        return new Envelope(\\n            subject: \'Verify Email\',\\n        );\\n    }\\n\\n    public function content()\\n    {\\n        return new Content(\\n            view: \'emails.verify-email\',\\n            with: [\\n                \'url\' => URL::temporarySignedRoute(\\n                    \'verify-email\',\\n                    now()->addMinutes(30),\\n                    [\'workflow_id\' => $this->workflowId],\\n                ),\\n            ],\\n        );\\n    }\\n\\n    public function attachments()\\n    {\\n        return [];\\n    }\\n}\\n```\\n\\nThe user gets the URL in a clickable link.\\n\\n```\\n<a href=\\"{{ $url }}\\">verification link</a>\\n```\\n\\nThis link takes the user to the `verify-email` route from our API routes, which will then start the final activity.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Models\\\\User;\\nuse Workflow\\\\Activity;\\n\\nclass VerifyEmailActivity extends Activity\\n{\\n    public function execute($email, $password)\\n    {\\n        $user = new User();\\n        $user->name = \'\';\\n        $user->email = $email;\\n        $user->email_verified_at = now();\\n        $user->password = $password;\\n        $user->save();\\n    }\\n}\\n```\\n\\nWe have created the user and verified their email address at the same time. Neat!\\n\\nWrapping Up\\n===========\\n\\nIf we take a look at the output of `php artisan queue:work` we can better see how the workflow and individual activities are interleaved.\\n\\n![queue worker](https://miro.medium.com/max/1400/1*q6-r41SN-uWfzp6p7Z4r8g.webp)\\n\\nWe can see the four different executions of the workflow, the individual activities and the signal we sent.\\n\\nThe [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library is heavily inspired by [Temporal](https://temporal.io/) but powered by [Laravel Queues](https://laravel.com/docs/9.x/queues).\\n\\nThanks for reading!"}]}')}}]);