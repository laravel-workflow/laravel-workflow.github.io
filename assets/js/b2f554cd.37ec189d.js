"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"automating-qa-with-playwright-and-laravel-workflow","metadata":{"permalink":"/blog/automating-qa-with-playwright-and-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2025-02-07-automating-qa-with-playwright-and-laravel-workflow.md","source":"@site/blog/2025-02-07-automating-qa-with-playwright-and-laravel-workflow.md","title":"Automating QA with Playwright and Laravel Workflow","description":"captionless image","date":"2025-02-07T00:00:00.000Z","formattedDate":"February 7, 2025","tags":[{"label":"playwright","permalink":"/blog/tags/playwright"},{"label":"laravel-workflow","permalink":"/blog/tags/laravel-workflow"},{"label":"automation","permalink":"/blog/tags/automation"},{"label":"qa","permalink":"/blog/tags/qa"},{"label":"testing","permalink":"/blog/tags/testing"}],"readingTime":3.715,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"automating-qa-with-playwright-and-laravel-workflow","title":"Automating QA with Playwright and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["playwright","laravel-workflow","automation","qa","testing"]},"nextItem":{"title":"Extending Laravel Workflow to Support Spatie Laravel Tags","permalink":"/blog/extending-laravel-workflow-to-support-spatie-laravel-tags"}},"content":"![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6eXVs5J3aRNzYAiqnS9Vw.png)\\n\\nHave you ever spent hours tracking down a frontend bug that only happens in production? When working with web applications, debugging frontend issues can be challenging. Console errors and unexpected UI behaviors often require careful inspection and reproducible test cases. Wouldn\u2019t it be great if you could automate this process, capture errors, and even record a video of the session for later analysis?\\n\\nWith **Playwright** and **Laravel Workflow**, you can achieve just that! In this post, I\u2019ll walk you through an automated workflow that:\\n\\n*   Loads a webpage and captures console errors.\\n*   Records a video of the session.\\n*   Converts the video to an MP4 format for easy sharing.\\n*   Runs seamlessly in a **GitHub Codespace**.\\n\\nThe Stack\\n=========\\n\\n*   **Playwright**: A powerful browser automation tool for testing web applications.\\n*   **Laravel Workflow**: A durable workflow engine for handling long-running, distributed processes.\\n*   **FFmpeg**: Used to convert Playwright\u2019s WebM recordings to MP4 format.\\n\\n![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AcR_sLHGToBWQx-SCSPHA.png)\\n\\n# 1. Capturing Errors and Video with Playwright\\n\\nThe Playwright script automates a browser session, navigates to a given URL, and logs any console errors. It also records a video of the entire session.\\n\\n```javascript\\nimport { chromium } from \'playwright\';\\nimport path from \'path\';\\nimport fs from \'fs\';\\n\\n(async () => {\\n    const url = process.argv[2];\\n    const videoDir = path.resolve(\'./videos\');\\n\\n    if (!fs.existsSync(videoDir)) {\\n        fs.mkdirSync(videoDir, { recursive: true });\\n    }\\n\\n    const browser = await chromium.launch({ args: [\'--no-sandbox\'] });\\n    const context = await browser.newContext({\\n        recordVideo: { dir: videoDir }\\n    });\\n\\n    const page = await context.newPage();\\n\\n    let errors = [];\\n\\n    page.on(\'console\', msg => {\\n        if (msg.type() === \'error\') {\\n            errors.push(msg.text());\\n        }\\n    });\\n\\n    try {\\n        await page.goto(url, { waitUntil: \'networkidle\', timeout: 10000 });\\n    } catch (error) {\\n        errors.push(`Page load error: ${error.message}`);\\n    }\\n    const video = await page.video().path();\\n\\n    await browser.close();\\n\\n    console.log(JSON.stringify({ errors, video }));\\n})();\\n```\\n\\n# 2. Running the Workflow\\n\\nA Laravel console command (`php artisan app:playwright`) starts the workflow which:\\n\\n*   Runs the Playwright script and collects errors.\\n*   Converts the video from `.webm` to `.mp4` using FFmpeg.\\n*   Returns the errors and the final video file path.\\n\\n```php\\nnamespace App\\\\Console\\\\Commands;\\n\\nuse App\\\\Workflows\\\\Playwright\\\\CheckConsoleErrorsWorkflow;\\nuse Illuminate\\\\Console\\\\Command;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass Playwright extends Command\\n{\\n    protected $signature = \'app:playwright\';\\n\\n    protected $description = \'Runs a playwright workflow\';\\n\\n    public function handle()\\n    {\\n        $workflow = WorkflowStub::make(CheckConsoleErrorsWorkflow::class);\\n        $workflow->start(\'https://example.com\');\\n        while ($workflow->running());\\n        $this->info($workflow->output()[\'mp4\']);\\n    }\\n}\\n```\\n\\n# 3. The Workflow\\n\\n```php\\nnamespace App\\\\Workflows\\\\Playwright;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass CheckConsoleErrorsWorkflow extends Workflow\\n{\\n    public function execute(string $url)\\n    {\\n        $result = yield ActivityStub::make(CheckConsoleErrorsActivity::class, $url);\\n\\n        $mp4 = yield ActivityStub::make(ConvertVideoActivity::class, $result[\'video\']);\\n\\n        return [\\n            \'errors\' => $result[\'errors\'],\\n            \'mp4\' => $mp4,\\n        ];\\n    }\\n}\\n```\\n\\n# 4. Running Playwright\\n\\n```php\\nnamespace App\\\\Workflows\\\\Playwright;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Process;\\nuse Workflow\\\\Activity;\\n\\nclass CheckConsoleErrorsActivity extends Activity\\n{\\n    public function execute(string $url)\\n    {\\n        $result = Process::run([\\n            \'node\', base_path(\'playwright-script.js\'), $url\\n        ])->throw();\\n\\n        return json_decode($result->output(), true);\\n    }\\n}\\n```\\n\\n# 5. Video Conversion with FFmpeg\\n\\nThe Playwright recording is stored in WebM format, but we need an MP4 for wider compatibility. Laravel Workflow runs this process asynchronously.\\n\\n```php\\nnamespace App\\\\Workflows\\\\Playwright;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Process;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertVideoActivity extends Activity\\n{\\n    public function execute(string $webm)\\n    {\\n        $mp4 = str_replace(\'.webm\', \'.mp4\', $webm);\\n\\n        Process::run([\\n            \'ffmpeg\', \'-i\', $webm, \'-c:v\', \'libx264\', \'-preset\', \'fast\', \'-crf\', \'23\', \'-c:a\', \'aac\', \'-b:a\', \'128k\', $mp4\\n        ])->throw();\\n\\n        unlink($webm);\\n\\n        return $mp4;\\n    }\\n}\\n```\\n\\n## Try It Out in a GitHub Codespace \ud83d\ude80\\n\\nYou don\u2019t need to set up anything on your local machine. Everything is already configured in the **Laravel Workflow Sample App**.\\n\\n# Steps to Run the Playwright Workflow\\n\\n*   Open the **Laravel Workflow Sample App** on GitHub: [laravel-workflow/sample-app](https://github.com/laravel-workflow/sample-app)\\n*   Click **\u201cCreate codespace on main\u201d** to start a pre-configured development environment.\\n\\n![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*063hPvkrvDQP6gU-VYb0Ug.png)\\n\\n*   Once the Codespace is ready, run the following commands in the terminal:\\n\\n```bash\\nphp artisan migrate\\nphp artisan queue:work\\n```\\n\\n*   Then open a second terminal and run this command:\\n\\n```bash\\nphp artisan app:playwright\\n```\\n\\nThat\u2019s it! The workflow will execute, capture console errors, record a video, and convert it to MP4. You can find the video in the videos folder. Take a look at the sample app\u2019s README.md for more information on other workflows and how to view the Waterline UI.\\n\\n# Conclusion\\n\\nBy integrating Playwright with Laravel Workflow, we\u2019ve automated frontend error detection and debugging. This setup allows teams to quickly identify and resolve issues, all while leveraging Laravel\u2019s queue system to run tasks asynchronously.\\n\\n## \ud83d\udd17 **Next Steps:**\\n\\n*   Check out the [Laravel Workflow repo](https://github.com/laravel-workflow/laravel-workflow) on GitHub.\\n*   Explore more workflows in the [sample app](https://github.com/laravel-workflow/sample-app).\\n*   Join the community and share your workflows!\\n\\nHappy automating! \ud83d\ude80"},{"id":"extending-laravel-workflow-to-support-spatie-laravel-tags","metadata":{"permalink":"/blog/extending-laravel-workflow-to-support-spatie-laravel-tags","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-08-28-extending-laravel-workflow-to-support-spatie-laravel-tags.md","source":"@site/blog/2023-08-28-extending-laravel-workflow-to-support-spatie-laravel-tags.md","title":"Extending Laravel Workflow to Support Spatie Laravel Tags","description":"captionless image","date":"2023-08-28T00:00:00.000Z","formattedDate":"August 28, 2023","tags":[{"label":"laravel","permalink":"/blog/tags/laravel"},{"label":"workflow","permalink":"/blog/tags/workflow"},{"label":"spatie","permalink":"/blog/tags/spatie"},{"label":"tags","permalink":"/blog/tags/tags"},{"label":"automation","permalink":"/blog/tags/automation"}],"readingTime":1.685,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"extending-laravel-workflow-to-support-spatie-laravel-tags","title":"Extending Laravel Workflow to Support Spatie Laravel Tags","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["laravel","workflow","spatie","tags","automation"]},"prevItem":{"title":"Automating QA with Playwright and Laravel Workflow","permalink":"/blog/automating-qa-with-playwright-and-laravel-workflow"},"nextItem":{"title":"AI Image Moderation with Laravel Workflow","permalink":"/blog/ai-image-moderation-with-laravel-workflow"}},"content":"![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YFhkvL6nZ3ny4NjGe6sMQ.png)\\n\\n## One of the strengths of the Laravel ecosystem is its flexibility, thanks to a myriad of community-driven packages that enhance the framework\u2019s capabilities. The `laravel-workflow` and `spatie/laravel-tags` packages are two such examples, and in this post, we\'ll integrate them together to make workflows taggable.\\n\\n## Installation Instructions\\n\\nBefore diving into the code, let\u2019s ensure both libraries are properly installed:\\n\\n1. Install [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) and [Spatie Laravel Tags](https://github.com/spatie/laravel-tags).\\n```sh\\ncomposer require laravel-workflow/laravel-workflow spatie/laravel-tags\\n```\\n\\n2. Both packages include migrations that must be published.\\n```sh\\nphp artisan vendor:publish --provider=\\"Workflow\\\\Providers\\\\WorkflowServiceProvider\\" --tag=\\"migrations\\"\\nphp artisan vendor:publish --provider=\\"Spatie\\\\Tags\\\\TagsServiceProvider\\" --tag=\\"tags-migrations\\"\\n```\\n\\n3. Run the migrations.\\n```sh\\nphp artisan migrate\\n```\\n\\n## Publishing Configuration\\n\\nTo extend Laravel Workflow, publish its configuration file:\\n```sh\\nphp artisan vendor:publish --provider=\\"Workflow\\\\Providers\\\\WorkflowServiceProvider\\" --tag=\\"config\\"\\n```\\n\\n## Extending Workflows to Support Tags\\n\\nWe need to extend the `StoredWorkflow` model of `laravel-workflow` to support tagging.\\n\\n```php\\nnamespace App\\\\Models;\\n\\nuse Spatie\\\\Tags\\\\HasTags;\\nuse Workflow\\\\Models\\\\StoredWorkflow as BaseStoredWorkflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass StoredWorkflow extends BaseStoredWorkflow\\n{\\n    use HasTags;\\n    \\n    public static function tag(WorkflowStub $workflow, $tag): void\\n    {\\n        $storedWorkflow = static::find($workflow->id());\\n        if ($storedWorkflow) {\\n            $storedWorkflow->attachTag($tag);\\n        }\\n    }\\n    \\n    public static function findByTag($tag): ?WorkflowStub\\n    {\\n        $storedWorkflow = static::withAnyTags([$tag])->first();\\n        if ($storedWorkflow) {\\n            return WorkflowStub::fromStoredWorkflow($storedWorkflow);\\n        }\\n    }\\n}\\n```\\n\\n## Modify the Configuration\\n\\nIn `config/workflow.php`, update this line:\\n```php\\n\'stored_workflow_model\' => Workflow\\\\Models\\\\StoredWorkflow::class,\\n```\\nTo:\\n```php\\n\'stored_workflow_model\' => App\\\\Models\\\\StoredWorkflow::class,\\n```\\nThis ensures Laravel Workflow uses the extended model.\\n\\n## Running Tagged Workflows\\n\\nWith the taggable `StoredWorkflow` ready, create a console command to create, tag, retrieve, and run a workflow.\\n\\n```php\\nnamespace App\\\\Console\\\\Commands;\\n\\nuse App\\\\Models\\\\StoredWorkflow;\\nuse App\\\\Workflows\\\\Simple\\\\SimpleWorkflow;\\nuse Illuminate\\\\Console\\\\Command;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass Workflow extends Command\\n{\\n    protected $signature = \'workflow\';\\n\\n    protected $description = \'Runs a workflow\';\\n\\n    public function handle()\\n    {\\n        // Create a workflow and tag it\\n        $workflow = WorkflowStub::make(SimpleWorkflow::class);\\n        StoredWorkflow::tag($workflow, \'tag1\');\\n        \\n        // Find the workflow by tag and start it\\n        $workflow = StoredWorkflow::findByTag(\'tag1\');\\n        $workflow->start();\\n        \\n        while ($workflow->running());\\n        \\n        $this->info($workflow->output());\\n    }\\n}\\n```\\n\\n## Conclusion\\n\\nBy integrating `laravel-workflow` with `spatie/laravel-tags`, we\'ve enabled tagging for workflows, making management more intuitive in larger applications. Thanks to Laravel\u2019s extensible nature, endless possibilities await developers leveraging these powerful packages."},{"id":"ai-image-moderation-with-laravel-workflow","metadata":{"permalink":"/blog/ai-image-moderation-with-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-08-20-ai-image-moderation-with-laravel-workflow.md","source":"@site/blog/2023-08-20-ai-image-moderation-with-laravel-workflow.md","title":"AI Image Moderation with Laravel Workflow","description":"captionless image","date":"2023-08-20T00:00:00.000Z","formattedDate":"August 20, 2023","tags":[{"label":"ai","permalink":"/blog/tags/ai"},{"label":"image-moderation","permalink":"/blog/tags/image-moderation"},{"label":"laravel-workflow","permalink":"/blog/tags/laravel-workflow"},{"label":"automation","permalink":"/blog/tags/automation"}],"readingTime":2.62,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"ai-image-moderation-with-laravel-workflow","title":"AI Image Moderation with Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["ai","image-moderation","laravel-workflow","automation"]},"prevItem":{"title":"Extending Laravel Workflow to Support Spatie Laravel Tags","permalink":"/blog/extending-laravel-workflow-to-support-spatie-laravel-tags"},"nextItem":{"title":"Microservice Communication with Laravel Workflow","permalink":"/blog/microservice-communication-with-laravel-workflow"}},"content":"![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sz-f9McEdB5UIlr55GOjyw.png)\\n\\n## Introduction\\n\\nBefore we begin, let\u2019s understand the scenario. We are building an image moderation system where:\\n\\n1. Every image undergoes an initial AI check to determine if it\u2019s safe.\\n2. If the AI deems the image unsafe, it\u2019s automatically logged and deleted.\\n3. If it\u2019s potentially safe, a human moderator is alerted to further review the image. They have the option to approve or reject the image.\\n4. Approved images are moved to a public location, whereas rejected images are deleted.\\n\\n## Laravel Workflow\\n\\nLaravel Workflow is designed to streamline and organize complex processes in applications. It allows developers to define, manage, and execute workflows seamlessly. You can find installation instructions [here](https://github.com/laravel-workflow/laravel-workflow).\\n\\n## ClarifAI API\\n\\nClarifAI provides AI-powered moderation tools for analyzing visual content. They offer a [free plan](https://www.clarifai.com/pricing) with up to 1,000 actions per month.\\n\\n### 1. Store your credentials in `.env`.\\n```ini\\nCLARIFAI_API_KEY=key\\nCLARIFAI_APP=my-application\\nCLARIFAI_WORKFLOW=my-workflow\\nCLARIFAI_USER=username\\n```\\n\\n### 2. Add the service to `config/services.php`.\\n```php\\n\'clarifai\' => [\\n    \'api_key\' => env(\'CLARIFAI_API_KEY\'),\\n    \'app\' => env(\'CLARIFAI_APP\'),\\n    \'workflow\' => env(\'CLARIFAI_WORKFLOW\'),\\n    \'user\' => env(\'CLARIFAI_USER\'),\\n],\\n```\\n\\n### 3. Create a service at `app/Services/ClarifAI.php`.\\n```php\\nnamespace App\\\\Services;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\n\\nclass ClarifAI\\n{\\n    private $apiKey;\\n    private $apiUrl;\\n\\n    public function __construct()\\n    {\\n        $app = config(\'services.clarifai.app\');\\n        $workflow = config(\'services.clarifai.workflow\');\\n        $user = config(\'services.clarifai.user\');\\n        $this->apiKey = config(\'services.clarifai.api_key\');\\n        $this->apiUrl = \\"https://api.clarifai.com/v2/users/{$user}/apps/{$app}/workflows/{$workflow}/results/\\";\\n    }\\n\\n    public function checkImage(string $image): bool\\n    {\\n        $response = Http::withToken($this->apiKey, \'Key\')\\n            ->post($this->apiUrl, [\'inputs\' => [\\n                [\'data\' => [\'image\' => [\'base64\' => base64_encode($image)]]],\\n            ]]);\\n\\n        return collect($response->json(\'results.0.outputs.0.data.concepts\', []))\\n            ->filter(fn ($value) => $value[\'name\'] === \'safe\')\\n            ->map(fn ($value) => round((float) $value[\'value\']) > 0)\\n            ->first() ?? false;\\n    }\\n}\\n```\\n\\n## Creating the Workflow\\n\\n```php\\nnamespace App\\\\Workflows;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\SignalMethod;\\nuse Workflow\\\\WorkflowStub;\\nuse Workflow\\\\Workflow;\\n\\nclass ImageModerationWorkflow extends Workflow\\n{\\n    private bool $approved = false;\\n    private bool $rejected = false;\\n\\n    #[SignalMethod]\\n    public function approve()\\n    {\\n        $this->approved = true;\\n    }\\n\\n    #[SignalMethod]\\n    public function reject()\\n    {\\n        $this->rejected = true;\\n    }\\n\\n    public function execute($imagePath)\\n    {\\n        $safe = yield from $this->check($imagePath);\\n\\n        if (! $safe) {\\n            yield from $this->unsafe($imagePath);\\n            return \'unsafe\';\\n        }\\n\\n        yield from $this->moderate($imagePath);\\n\\n        return $this->approved ? \'approved\' : \'rejected\';\\n    }\\n\\n    private function check($imagePath)\\n    {\\n        return yield ActivityStub::make(AutomatedImageCheckActivity::class, $imagePath);\\n    }\\n\\n    private function unsafe($imagePath)\\n    {\\n        yield ActivityStub::all([\\n            ActivityStub::make(LogUnsafeImageActivity::class, $imagePath),\\n            ActivityStub::make(DeleteImageActivity::class, $imagePath),\\n        ]);\\n    }\\n\\n    private function moderate($imagePath)\\n    {\\n        while (true) {\\n            yield ActivityStub::make(NotifyImageModeratorActivity::class, $imagePath);\\n\\n            $signaled = yield WorkflowStub::awaitWithTimeout(\'24 hours\', fn () => $this->approved || $this->rejected);\\n\\n            if ($signaled) break;\\n        }\\n    }\\n}\\n```\\n\\n## Activities\\n\\n### Automated Image Check\\n```php\\nnamespace App\\\\Workflows;\\n\\nuse App\\\\Services\\\\ClarifAI;\\nuse Illuminate\\\\Support\\\\Facades\\\\Storage;\\nuse Workflow\\\\Activity;\\n\\nclass AutomatedImageCheckActivity extends Activity\\n{\\n    public function execute($imagePath)\\n    {\\n        return app(ClarifAI::class)\\n            ->checkImage(Storage::get($imagePath));\\n    }\\n}\\n```\\n\\n### Logging Unsafe Images\\n```php\\nnamespace App\\\\Workflows;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Log;\\nuse Workflow\\\\Activity;\\n\\nclass LogUnsafeImageActivity extends Activity\\n{\\n    public function execute($imagePath)\\n    {\\n        Log::info(\'Unsafe image detected at: \' . $imagePath);\\n    }\\n}\\n```\\n\\n### Deleting Images\\n```php\\nnamespace App\\\\Workflows;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Storage;\\nuse Workflow\\\\Activity;\\n\\nclass DeleteImageActivity extends Activity\\n{\\n    public function execute($imagePath)\\n    {\\n        Storage::delete($imagePath);\\n    }\\n}\\n```\\n\\n## Starting and Signaling the Workflow\\n```php\\n$workflow = WorkflowStub::make(ImageModerationWorkflow::class);\\n$workflow->start(\'tmp/good.jpg\');\\n```\\n\\nFor approvals or rejections:\\n```php\\n$workflow = WorkflowStub::load($id);\\n$workflow->approve();\\n// or\\n$workflow->reject();\\n```\\n\\n## Conclusion\\n\\n[Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) provides a structured approach to handle complex processes like image moderation. It supports asynchronous processing, external API integrations, and modular design for scalability. Thanks for reading!"},{"id":"microservice-communication-with-laravel-workflow","metadata":{"permalink":"/blog/microservice-communication-with-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-08-18-microservice-communication-with-laravel-workflow.md","source":"@site/blog/2023-08-18-microservice-communication-with-laravel-workflow.md","title":"Microservice Communication with Laravel Workflow","description":"captionless image","date":"2023-08-18T00:00:00.000Z","formattedDate":"August 18, 2023","tags":[{"label":"microservices","permalink":"/blog/tags/microservices"},{"label":"laravel-workflow","permalink":"/blog/tags/laravel-workflow"},{"label":"communication","permalink":"/blog/tags/communication"},{"label":"distributed-systems","permalink":"/blog/tags/distributed-systems"}],"readingTime":3.84,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"microservice-communication-with-laravel-workflow","title":"Microservice Communication with Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["microservices","laravel-workflow","communication","distributed-systems"]},"prevItem":{"title":"AI Image Moderation with Laravel Workflow","permalink":"/blog/ai-image-moderation-with-laravel-workflow"},"nextItem":{"title":"Saga Pattern and Laravel Workflow","permalink":"/blog/saga-pattern-and-laravel-workflow"}},"content":"![captionless image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCy08NPtCpERqC09SVBFfg.jpeg)\\n\\nIn the evolving landscape of microservices, communication has always been a focal point. Microservices can interact in various ways, be it through HTTP/REST calls, using messaging protocols like RabbitMQ or Kafka, or even employing more recent technologies like gRPC. Yet, regardless of the communication method, the goal remains the same: seamless, efficient, and robust interactions. Today, we\u2019ll explore how Laravel Workflow can fit into this picture and optimize the communication between microservices in a unique way.\\n\\n## The Challenge\\n\\nIn a microservices architecture, decoupling is the name of the game. You want each service to have a single responsibility, to be maintainable, and to be independently deployable. Yet, in the world of workflows, this becomes challenging. How do you split a workflow from its activity and yet ensure they communicate seamlessly?\\n\\n## Laravel Workflow to the Rescue!\\n\\n[Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) handles the discovery and orchestration for you! With a shared database and queue connection, you can have your workflow in one Laravel app and its activity logic in another.\\n\\n### Defining Workflows and Activities\\n\\n#### 1. Create a workflow.\\n```php\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass MyWorkflow extends Workflow\\n{\\n    public function execute($name)\\n    {\\n        $result = yield ActivityStub::make(MyActivity::class, $name);\\n        return $result;\\n    }\\n}\\n```\\n\\n#### 2. Create an activity.\\n```php\\nuse Workflow\\\\Activity;\\n\\nclass MyActivity extends Activity\\n{\\n    public function execute($name)\\n    {\\n        return \\"Hello, {$name}!\\";\\n    }\\n}\\n```\\n\\n#### 3. Run the workflow.\\n```php\\nuse Workflow\\\\WorkflowStub;\\n\\n$workflow = WorkflowStub::make(MyWorkflow::class);\\n$workflow->start(\'world\');\\nwhile ($workflow->running());\\n$workflow->output();\\n// Output: \'Hello, world!\'\\n```\\n\\nThe workflow will manage the activity and handle any failures, retries, etc. Think of workflows like job chaining on steroids because you can have conditional logic, loops, return a result that can be used in the next activity, and write everything in typical PHP code that is failure tolerant.\\n\\n## Balancing Shared and Dedicated Resources\\n\\nWhen working with microservices, it\u2019s common for each service to have its dedicated resources, such as databases, caches, and queues. However, to facilitate communication between workflows and activities across services, a shared connection (like a database or queue) becomes essential. This shared connection acts as a bridge for data and task exchanges while ensuring:\\n\\n1. **Isolation**: Dedicated resources prevent cascading failures.\\n2. **Performance**: Each service can be optimized independently.\\n3. **Security**: Isolation limits potential attack vectors.\\n\\n## Step-By-Step Integration\\n\\n### 1. Install `laravel-workflow` in all microservices.\\nFollow the [installation guide](https://laravel-workflow.com/docs/installation/).\\n\\n### 2. Create a shared database/redis connection in all microservices.\\n```php\\n// config/database.php\\n\'connections\' => [\\n    \'shared\' => [\\n        \'driver\' => \'mysql\',\\n        \'host\' => env(\'SHARED_DB_HOST\', \'127.0.0.1\'),\\n        \'database\' => env(\'SHARED_DB_DATABASE\', \'forge\'),\\n        \'username\' => env(\'SHARED_DB_USERNAME\', \'forge\'),\\n        \'password\' => env(\'SHARED_DB_PASSWORD\', \'\'),\\n    ],\\n],\\n```\\n\\n### 3. Configure a shared queue connection.\\n```php\\n// config/queue.php\\n\'connections\' => [\\n    \'shared\' => [\\n        \'driver\' => \'redis\',\\n        \'connection\' => \'shared\',\\n        \'queue\' => env(\'SHARED_REDIS_QUEUE\', \'default\'),\\n    ],\\n],\\n```\\n\\n### 4. Ensure only one microservice publishes Laravel Workflow migrations.\\nUpdate the migration to use the shared database connection.\\n```php\\n// database/migrations/..._create_workflows_table.php\\nclass CreateWorkflowsTable extends Migration\\n{\\n    protected $connection = \'shared\';\\n}\\n```\\n\\n### 5. Extend workflow models in each microservice to use the shared connection.\\n```php\\n// app/Models/StoredWorkflow.php\\nnamespace App\\\\Models;\\nuse Workflow\\\\Models\\\\StoredWorkflow as BaseStoredWorkflow;\\n\\nclass StoredWorkflow extends BaseStoredWorkflow\\n{\\n    protected $connection = \'shared\';\\n}\\n```\\n\\n### 6. Publish Laravel Workflow config and update it with shared models.\\n```sh\\nphp artisan vendor:publish --provider=\\"Workflow\\\\Providers\\\\WorkflowServiceProvider\\" --tag=\\"config\\"\\n```\\n\\n### 7. Set workflows and activities to use the shared queue.\\n```php\\n// app/Workflows/MyWorkflow.php\\nclass MyWorkflow extends Workflow\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'workflow\';\\n}\\n```\\n```php\\n// app/Workflows/MyActivity.php\\nclass MyActivity extends Activity\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'activity\';\\n}\\n```\\n\\n### 8. Ensure microservices define empty counterparts for workflow and activity classes.\\n#### In the workflow microservice:\\n```php\\nclass MyWorkflow extends Workflow\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'workflow\';\\n    public function execute($name)\\n    {\\n        yield ActivityStub::make(MyActivity::class, $name);\\n    }\\n}\\nclass MyActivity extends Activity\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'activity\';\\n}\\n```\\n\\n#### In the activity microservice:\\n```php\\nclass MyWorkflow extends Workflow\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'workflow\';\\n}\\nclass MyActivity extends Activity\\n{\\n    public $connection = \'shared\';\\n    public $queue = \'activity\';\\n    public function execute($name)\\n    {\\n        return \\"Hello, {$name}!\\";\\n    }\\n}\\n```\\n\\n### 9. Ensure all microservices have the same `APP_KEY` in their `.env` file.\\nThis is crucial for proper job serialization across services.\\n\\n### 10. Run queue workers in each microservice.\\n```sh\\nphp artisan queue:work shared --queue=workflow\\nphp artisan queue:work shared --queue=activity\\n```\\n\\n## Conclusion\\nBy following the steps above, you can ensure seamless interactions between microservices while maintaining modularity and scalability. Laravel Workflow takes care of the discovery and orchestration for you. \ud83d\ude80\\n\\nThanks for reading!"},{"id":"saga-pattern-and-laravel-workflow","metadata":{"permalink":"/blog/saga-pattern-and-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-05-21-saga-pattern-and-laravel-workflow.md","source":"@site/blog/2023-05-21-saga-pattern-and-laravel-workflow.md","title":"Saga Pattern and Laravel Workflow","description":"Suppose we are working on a Laravel application that offers trip booking. A typical trip booking involves several steps such as:","date":"2023-05-21T00:00:00.000Z","formattedDate":"May 21, 2023","tags":[{"label":"sagas","permalink":"/blog/tags/sagas"},{"label":"microservices","permalink":"/blog/tags/microservices"}],"readingTime":4.09,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"saga-pattern-and-laravel-workflow","title":"Saga Pattern and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["sagas","microservices"]},"prevItem":{"title":"Microservice Communication with Laravel Workflow","permalink":"/blog/microservice-communication-with-laravel-workflow"},"nextItem":{"title":"Combining Laravel Workflow and State Machines","permalink":"/blog/combining-laravel-workflow-and-state-machines"}},"content":"Suppose we are working on a Laravel application that offers trip booking. A typical trip booking involves several steps such as:\\n\\n1.  Booking a flight.\\n2.  Booking a hotel.\\n3.  Booking a rental car.\\n\\nOur customers expect an all-or-nothing transaction \u2014 it doesn\u2019t make sense to book a hotel without a flight. Now imagine each of these booking steps being represented by a distinct API.\\n\\nTogether, these steps form a distributed transaction spanning multiple services and databases. For a successful booking, all three APIs must accomplish their individual local transactions. If any step fails, the preceding successful transactions need to be reversed in an orderly fashion. With money and bookings at stake, we can\u2019t merely erase prior transactions \u2014 we need an immutable record of attempts and failures. Thus, we should compile a list of compensatory actions for execution in the event of a failure.\\n\\nPrerequisites\\n=============\\n\\nTo follow this tutorial, you should:\\n\\n1.  Set up a local development environment for Laravel Workflow applications in PHP or use the sample app in a GitHub [codespace](https://github.com/laravel-workflow/sample-app).\\n2.  Familiarize yourself with the basics of starting a Laravel Workflow project by reviewing the [documentation](https://laravel-workflow.com/docs/installation).\\n3.  Review the [Saga architecture pattern](https://microservices.io/patterns/data/saga.html).\\n\\nSagas are an established design pattern for managing complex, long-running operations:\\n\\n1.  A Saga manages transactions using a sequence of local transactions.\\n2.  A local transaction is a work unit performed by a saga participant (a microservice).\\n3.  Each operation in the Saga can be reversed by a compensatory transaction.\\n4.  The Saga pattern assures that all operations are either completed successfully or the corresponding compensation transactions are run to reverse any completed work.\\n\\nLaravel Workflow provides inherent support for the Saga pattern, simplifying the process of handling rollbacks and executing compensatory transactions.\\n\\nBooking Saga Flow\\n=================\\n\\nWe will visualize the Saga pattern for our trip booking scenario with a diagram.\\n\\n![trip booking saga](https://miro.medium.com/v2/1*WD1_N0mIdeDtIPycKQj6yQ.png)\\n\\nWorkflow Implementation\\n-----------------------\\n\\nWe\u2019ll begin by creating a high-level flow of our trip booking process, which we\u2019ll name `BookingSagaWorkflow`.\\n\\n```php\\nclass BookingSagaWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n    }  \\n}\\n```\\n\\nNext, we\u2019ll imbue our saga with logic, by adding booking steps:\\n\\n```php\\nclass BookingSagaWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n        try {  \\n            $flightId = yield ActivityStub::make(BookFlightActivity::class);  \\n            $hotelId = yield ActivityStub::make(BookHotelActivity::class);  \\n            $carId = yield ActivityStub::make(BookRentalCarActivity::class);  \\n        } catch (Throwable $th) {  \\n        }  \\n    }  \\n}\\n```\\n\\nEverything inside the `try` block is our \\"happy path\\". If any steps within this distributed transaction fail, we move into the `catch` block and execute compensations.\\n\\nAdding Compensations\\n--------------------\\n\\n```php\\nclass BookingSagaWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n        try {  \\n            $flightId = yield ActivityStub::make(BookFlightActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelFlightActivity::class, $flightId));  \\n  \\n            $hotelId = yield ActivityStub::make(BookHotelActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelHotelActivity::class, $hotelId));  \\n  \\n            $carId = yield ActivityStub::make(BookRentalCarActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelRentalCarActivity::class, $carId));  \\n        } catch (Throwable $th) {  \\n        }  \\n    }  \\n}\\n```\\n\\nIn the above code, we sequentially book a flight, a hotel, and a car. We use the `$this->addCompensation()` method to add a compensation, providing a callable to reverse a distributed transaction.\\n\\nExecuting the Compensation Strategy\\n-----------------------------------\\n\\nWith the above setup, we can finalize our saga and populate the `catch` block:\\n\\n```php\\nclass BookingSagaWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n        try {  \\n            $flightId = yield ActivityStub::make(BookFlightActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelFlightActivity::class, $flightId));  \\n  \\n            $hotelId = yield ActivityStub::make(BookHotelActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelHotelActivity::class, $hotelId));  \\n  \\n            $carId = yield ActivityStub::make(BookRentalCarActivity::class);  \\n            $this->addCompensation(fn () => ActivityStub::make(CancelRentalCarActivity::class, $carId));  \\n        } catch (Throwable $th) {  \\n            yield from $this->compensate();  \\n            throw $th;  \\n        }  \\n    }  \\n}\\n```\\n\\nWithin the `catch` block, we call the `compensate()` method, which triggers the compensation strategy and executes all previously registered compensation callbacks. Once done, we rethrow the exception for debugging.\\n\\nBy default, compensations execute sequentially. To run them in parallel, use `$this->setParallelCompensation(true)`. To ignore exceptions that occur inside compensation activities while keeping them sequential, use `$this->setContinueWithError(true)` instead.\\n\\nTesting the Workflow\\n--------------------\\n\\nLet\u2019s run this workflow with simulated failures in each activity to fully understand the process.\\n\\nFirst, we run the workflow normally to see the sequence of bookings: flight, then hotel, then rental car.\\n\\n![booking saga with no errors](https://miro.medium.com/v2/1*3IgEjKzHK8Fpp-uumr4dIw.png)\\n\\nNext, we simulate an error with the flight booking activity. Since no bookings were made, the workflow logs the exception and fails.\\n\\n![booking saga error with flight](https://miro.medium.com/v2/1*ZuDAFa_q0l2-PT6PhRguaw.png)\\n\\nThen, we simulate an error with the hotel booking activity. The flight is booked successfully, but when the hotel booking fails, the workflow cancels the flight.\\n\\n![booking saga error with hotel](https://miro.medium.com/v2/1*_OwO5PUOLFqcLfd38gNpEQ.png)\\n\\nFinally, we simulate an error with the rental car booking. The flight and hotel are booked successfully, but when the rental car booking fails, the workflow cancels the hotel first and then the flight.\\n\\n![booking saga error with rental car](https://miro.medium.com/v2/1*3qR9GKQH-YtghwPK_x9wUQ.png)\\n\\nConclusion\\n----------\\n\\nIn this tutorial, we implemented the Saga architecture pattern for distributed transactions in a microservices-based application using Laravel Workflow. Writing Sagas can be complex, but Laravel Workflow takes care of the difficult parts such as handling errors and retries, and invoking compensatory transactions, allowing us to focus on the details of our application."},{"id":"combining-laravel-workflow-and-state-machines","metadata":{"permalink":"/blog/combining-laravel-workflow-and-state-machines","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md","source":"@site/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md","title":"Combining Laravel Workflow and State Machines","description":"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library.","date":"2023-04-25T00:00:00.000Z","formattedDate":"April 25, 2023","tags":[{"label":"side-effects","permalink":"/blog/tags/side-effects"},{"label":"random","permalink":"/blog/tags/random"},{"label":"determinism","permalink":"/blog/tags/determinism"}],"readingTime":3.665,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"combining-laravel-workflow-and-state-machines","title":"Combining Laravel Workflow and State Machines","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["side-effects","random","determinism"]},"prevItem":{"title":"Saga Pattern and Laravel Workflow","permalink":"/blog/saga-pattern-and-laravel-workflow"},"nextItem":{"title":"Introducing Child Workflows in Laravel Workflow","permalink":"/blog/introducing-child-workflows-in-laravel-workflow"}},"content":"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library.\\n\\nBenefits of Combining Laravel Workflow and State Machines\\n=========================================================\\n\\nUsing Laravel Workflow and a state machine together provides several advantages:\\n\\n1.  Flexibility and modularity: Laravel Workflow allows developers to break down complex processes into smaller, modular units that are easy to maintain and update.\\n2.  Explicit control over transitions: State machines provide a clear visualization of workflow states, activities, and transitions, making it easier to understand and maintain.\\n3.  Robust error handling and retries: Laravel Workflow offers built-in support for handling errors and retries, ensuring that workflows are executed reliably and consistently.\\n4.  Scalability: Laravel Workflow supports queuing and parallel execution, allowing workflows to be executed asynchronously on worker servers.\\n5.  Integration with Laravel\u2019s queue and event systems: This allows for seamless integration with other Laravel features and packages.\\n\\nInstallation Guide\\n==================\\n\\nTo get started with Laravel Workflow and Finite, you will need to install them in your Laravel project:\\n\\nFor Laravel Workflow, run the following command:\\n\\n```bash\\ncomposer require laravel-workflow/laravel-workflow\\n```\\n\\nFor [Finite](https://github.com/yohang/Finite), run the following command:\\n\\n```bash\\ncomposer require yohang/finite\\n```\\n\\nLoan Application Workflow Example\\n=================================\\n\\nThe following code demonstrates how to create a `LoanApplicationWorkflow` using Laravel Workflow and Finite:\\n\\n```php\\nuse Finite\\\\StatefulInterface;  \\nuse Finite\\\\StateMachine\\\\StateMachine;  \\nuse Finite\\\\State\\\\State;  \\nuse Finite\\\\State\\\\StateInterface;  \\nuse Workflow\\\\Models\\\\StoredWorkflow;  \\nuse Workflow\\\\SignalMethod;  \\nuse Workflow\\\\WorkflowStub;  \\nuse Workflow\\\\Workflow;  \\n  \\nclass LoanApplicationWorkflow extends Workflow implements StatefulInterface  \\n{  \\n    private $state;  \\n    private $stateMachine;  \\n  \\n    public function setFiniteState($state)  \\n    {  \\n        $this->state = $state;  \\n    }  \\n  \\n    public function getFiniteState()  \\n    {  \\n        return $this->state;  \\n    }  \\n  \\n    #[SignalMethod]  \\n    public function submit()  \\n    {  \\n        $this->stateMachine->apply(\'submit\');  \\n    }  \\n  \\n    #[SignalMethod]  \\n    public function approve()  \\n    {  \\n        $this->stateMachine->apply(\'approve\');  \\n    }  \\n  \\n    #[SignalMethod]  \\n    public function deny()  \\n    {  \\n        $this->stateMachine->apply(\'deny\');  \\n    }  \\n  \\n    public function isSubmitted()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'submitted\';  \\n    }  \\n  \\n    public function isApproved()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'approved\';  \\n    }  \\n  \\n    public function isDenied()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'denied\';  \\n    }  \\n  \\n    public function __construct(  \\n        public StoredWorkflow $storedWorkflow,  \\n        ...$arguments  \\n    ) {  \\n        parent::__construct($storedWorkflow, $arguments);  \\n  \\n        $this->stateMachine = new StateMachine();  \\n  \\n        $this->stateMachine->addState(new State(\'created\', StateInterface::TYPE\\\\_INITIAL));  \\n        $this->stateMachine->addState(\'submitted\');  \\n        $this->stateMachine->addState(new State(\'approved\', StateInterface::TYPE\\\\_FINAL));  \\n        $this->stateMachine->addState(new State(\'denied\', StateInterface::TYPE\\\\_FINAL));  \\n  \\n        $this->stateMachine->addTransition(\'submit\', \'created\', \'submitted\');  \\n        $this->stateMachine->addTransition(\'approve\', \'submitted\', \'approved\');  \\n        $this->stateMachine->addTransition(\'deny\', \'submitted\', \'denied\');  \\n  \\n        $this->stateMachine->setObject($this);  \\n        $this->stateMachine->initialize();  \\n    }  \\n  \\n    public function execute()  \\n    {  \\n        // loan created  \\n  \\n        yield WorkflowStub::await(fn () => $this->isSubmitted());  \\n  \\n        // loan submitted  \\n  \\n        yield WorkflowStub::await(fn () => $this->isApproved() || $this->isDenied());  \\n  \\n        // loan approved/denied  \\n  \\n        return $this->stateMachine->getCurrentState()->getName();  \\n    }  \\n}\\n```\\n\\nIn this example, we define a `LoanApplicationWorkflow` class that extends `Workflow` and implements `StatefulInterface`. The workflow has four states: created, submitted, approved or denied. The workflow transitions between these states by externally calling the `submit()`, `approve()`, and `deny()` signal methods.\\n\\nTo use the `LoanApplicationWorkflow`, you can create a new instance of it, start the workflow, submit the loan application, approve it, and get the output as follows:\\n\\n```php\\n// create workflow  \\n$workflow = WorkflowStub::make(LoanApplicationWorkflow::class);  \\n  \\n// start workflow  \\n$workflow->start();  \\n  \\nsleep(1);  \\n  \\n// submit signal  \\n$workflow->submit();  \\n  \\nsleep(1);  \\n  \\n// approve signal  \\n$workflow->approve();  \\n  \\nsleep(1);  \\n  \\n$workflow->output();  \\n// \\"approved\\"\\n```\\n\\nThis is the view from [Waterline](https://github.com/laravel-workflow/waterline).\\n\\n![timeline](https://miro.medium.com/max/1400/1*m6cOftX9kjBjr6CJGpyQPA.webp)\\n\\nConclusion\\n==========\\n\\nAlthough Laravel Workflow offers a way to define and manage workflows and activities, some developers might still prefer to use a state machine to have more explicit control over the transitions between states or activities.\\n\\nA state machine can provide a more structured and visual representation of the workflow, making it easier to understand and maintain. In such cases, a state machine library can be integrated with Laravel Workflow. This allows developers to define their workflow states, activities, and transitions using the state machine library while still leveraging Laravel Workflow\u2019s features, such as queuing, parallel execution, error handling, retries, and integration with Laravel\u2019s queue and event systems.\\n\\nThe Laravel developer community has created several state machine packages that can be integrated with Laravel Workflow, such as the following:\\n\\n- https://github.com/yohang/Finite\\n- https://github.com/spatie/laravel-model-states\\n- https://github.com/sebdesign/laravel-state-machine\\n- https://github.com/symfony/workflow\\n\\nBy integrating a state machine library with Laravel Workflow, developers can get the best of both worlds: the flexibility and modularity of Laravel Workflow and the explicit control and visualization of a state machine. This can help to create more maintainable, robust, and scalable workflows for complex business processes."},{"id":"introducing-child-workflows-in-laravel-workflow","metadata":{"permalink":"/blog/introducing-child-workflows-in-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-05-introducing-child-workflows-in-laravel-workflow.md","source":"@site/blog/2023-04-05-introducing-child-workflows-in-laravel-workflow.md","title":"Introducing Child Workflows in Laravel Workflow","description":"Laravel Workflow has introduced an exciting new feature called \u201cChild Workflows.\u201d This addition aims to enhance the organization and maintainability of complex processes by allowing developers to encapsulate sub-processes within a parent workflow. This article will discuss the benefits of using child workflows, their similarities with running a workflow as an activity, and their compatibility with retry and resume features.","date":"2023-04-05T00:00:00.000Z","formattedDate":"April 5, 2023","tags":[{"label":"child-workflows","permalink":"/blog/tags/child-workflows"},{"label":"nesting","permalink":"/blog/tags/nesting"}],"readingTime":2.35,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"introducing-child-workflows-in-laravel-workflow","title":"Introducing Child Workflows in Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["child-workflows","nesting"]},"prevItem":{"title":"Combining Laravel Workflow and State Machines","permalink":"/blog/combining-laravel-workflow-and-state-machines"},"nextItem":{"title":"New Laravel Workflow Feature: Side Effects","permalink":"/blog/new-laravel-workflow-feature-side-effects"}},"content":"Laravel Workflow has introduced an exciting new feature called \u201cChild Workflows.\u201d This addition aims to enhance the organization and maintainability of complex processes by allowing developers to encapsulate sub-processes within a parent workflow. This article will discuss the benefits of using child workflows, their similarities with running a workflow as an activity, and their compatibility with retry and resume features.\\n\\nWhat are Child Workflows?\\n=========================\\n\\nIn Laravel Workflow, child workflows are a way to manage complex processes by breaking them down into smaller, more manageable units. They enable developers to create hierarchical and modular structures for their workflows, making them more organized and easier to maintain. A child workflow is essentially a separate workflow that is invoked within a parent workflow using the `ChildWorkflowStub::make()` method.\\n\\nBenefits of Using Child Workflows\\n=================================\\n\\n1.  Modularity: Child workflows promote modularity by allowing developers to encapsulate specific functionality within separate, reusable units. This enables better code organization and easier management of complex processes.\\n2.  Reusability: Child workflows can be invoked within multiple parent workflows, which encourages reusability and reduces code duplication.\\n3.  Maintainability: By breaking down complex processes into smaller units, developers can better understand, debug, and maintain their workflows.\\n\\nWorkflows as Activities\\n=======================\\n\\nChild workflows are similar to running a workflow as an activity in that they both encapsulate specific functionality within a parent workflow. However, child workflows offer more flexibility and reusability than activities.\\n\\n![chart](https://miro.medium.com/max/1400/1*pv55DNLlsn7wuNZSL8bXrg.webp)\\n\\nActivities are single-purpose units that perform a specific action within a workflow, such as sending an email or updating a database record. On the other hand, child workflows are complete workflows in themselves, which can be composed of multiple activities and even other child workflows. This allows developers to create complex, nested structures to manage intricate processes more efficiently.\\n\\nRetries and Resumes in Child Workflows\\n======================================\\n\\nChild workflows inherit the same retry and resume features as their parent workflows, enabling developers to manage error handling and recovery more effectively. When a child workflow fails, Laravel Workflow will automatically attempt to retry the failed operation, following the configured retry policy. If the child workflow still fails after all retries have been exhausted, the parent workflow can also be configured to handle the failure accordingly.\\n\\nIn addition, child workflows can be resumed if they are interrupted due to a system failure or crash. This ensures that the entire process can continue from the point of interruption without losing progress or requiring manual intervention.\\n\\nConclusion\\n==========\\n\\nLaravel Workflow\u2019s Child Workflows feature offers developers an effective way to manage complex processes by breaking them down into smaller, more manageable units. This enhances organization, maintainability, and reusability, making it easier for developers to build and maintain intricate workflows. With the added benefits of retry and resume features, child workflows provide a robust and efficient solution for managing complex processes in Laravel applications."},{"id":"new-laravel-workflow-feature-side-effects","metadata":{"permalink":"/blog/new-laravel-workflow-feature-side-effects","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-12-22-new-laravel-workflow-feature-side-effects.md","source":"@site/blog/2022-12-22-new-laravel-workflow-feature-side-effects.md","title":"New Laravel Workflow Feature: Side Effects","description":"effects","date":"2022-12-22T00:00:00.000Z","formattedDate":"December 22, 2022","tags":[{"label":"side-effects","permalink":"/blog/tags/side-effects"},{"label":"random","permalink":"/blog/tags/random"},{"label":"determinism","permalink":"/blog/tags/determinism"}],"readingTime":2.75,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"new-laravel-workflow-feature-side-effects","title":"New Laravel Workflow Feature: Side Effects","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["side-effects","random","determinism"]},"prevItem":{"title":"Introducing Child Workflows in Laravel Workflow","permalink":"/blog/introducing-child-workflows-in-laravel-workflow"},"nextItem":{"title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","permalink":"/blog/job-chaining-vs-fan-out-fan-in"}},"content":"![effects](https://miro.medium.com/max/1400/1*2CEWzQKvYNtpviILF-I-0Q.webp)\\n\\nWorkflows provide a more organized and structured approach to managing distributed processes, making it easier for developers to understand and work with complex logic.\\n\\nLaravel Workflow is a powerful package for the Laravel web framework that provides tools for defining and managing workflows.\\n\\nOne of the key features of any workflow engine is the ability to track the history of a workflow as it is executed which allows a workflow to be retried if it fails or encounters an error. However, this also means that your workflow code must be deterministic and any non-deterministic code has to be carefully managed.\\n\\nRecently, Laravel Workflow added support for [side effects](https://laravel-workflow.com/docs/features/side-effects), which are closures containing non-deterministic code that is only executed once and the result saved. Side effects are a useful way to introduce non-deterministic behavior into a workflow, such as generating a random number or UUID.\\n\\nHere is an example workflow that demonstrates side effects.\\n\\n```php\\nclass SideEffectWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n        $sideEffect = yield WorkflowStub::sideEffect(  \\n          fn () => random\\\\_int(PHP\\\\_INT\\\\_MIN, PHP\\\\_INT\\\\_MAX)  \\n        );  \\n  \\n        $badSideEffect = random\\\\_int(PHP\\\\_INT\\\\_MIN, PHP\\\\_INT\\\\_MAX);  \\n  \\n        $result1 = yield ActivityStub::make(SimpleActivity::class, $sideEffect);  \\n  \\n        $result2 = yield ActivityStub::make(SimpleActivity::class, $badSideEffect);  \\n  \\n        if ($sideEffect !== $result1) {  \\n            throw new Exception(  \\n                \'These side effects should match because it was properly wrapped in WorkflowStub::sideEffect().\'  \\n            );  \\n        }  \\n  \\n        if ($badSideEffect === $result2) {  \\n            throw new Exception(  \\n                \'These side effects should not match because it was not wrapped in WorkflowStub::sideEffect().\'  \\n            );  \\n        }  \\n    }  \\n}\\n```\\n\\nThe activity doesn\u2019t actually do anything. It just takes the input and passes it back out unmodified, so that we can compare the result to what we generated inside of the workflow.\\n\\n```php\\nclass SimpleActivity extends Activity  \\n{  \\n    public function execute($input)  \\n    {  \\n        return $input;  \\n    }  \\n}\\n```\\n\\nIn this example, the workflow generates two random integers: one using a side effect and the other using a local variable. The values of these integers are then passed to two different activities.\\n\\nThe first activity receives the value of the side effect, which has been saved. As a result, the value of the side effect should remain constant throughout the execution of the workflow.\\n\\nThe second activity receives the value of the local variable, which is not saved and will be regenerated. This means that the value of the local variable will change between executions of the workflow.\\n\\nAs a result, it is not expected that the value of the local variable will match the value returned from the second activity. The odds of two random integers generated using `random_int(PHP_INT_MIN, PHP_INT_MAX)` being equal are extremely low, since there are a very large number of possible integers in this range.\\n\\n![dice](https://miro.medium.com/max/1400/1*ElelNBBf4pbE3-nueJcriQ.webp)\\n\\nIt\u2019s important to use side effects appropriately in your workflow to ensure that your workflow is reliable and can recover from failures. Only use side effects for short pieces of code that cannot fail, and make sure to use activities to perform long-running work that may fail and need to be retried, such as API requests or external processes.\\n\\nOverall, side effects are a powerful tool for introducing non-deterministic behavior into your workflows. When used correctly, they can help you to add more flexibility and complexity to your application\u2019s logic.\\n\\nLaravel Workflow is a powerful tool for managing workflows in your Laravel applications, and the addition of support for side effects makes it even more powerful!"},{"id":"job-chaining-vs-fan-out-fan-in","metadata":{"permalink":"/blog/job-chaining-vs-fan-out-fan-in","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-12-06-job-chaining-vs-fan-out-fan-in.md","source":"@site/blog/2022-12-06-job-chaining-vs-fan-out-fan-in.md","title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","description":"Chaining is a workflow design pattern that involves the sequential execution of a series of activities, with the output of one activity potentially serving as the input to the next activity in the chain. This pattern is often used to create a linear, step-by-step process for completing a task.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"chaining","permalink":"/blog/tags/chaining"},{"label":"fan-out","permalink":"/blog/tags/fan-out"},{"label":"fan-in","permalink":"/blog/tags/fan-in"},{"label":"batching","permalink":"/blog/tags/batching"}],"readingTime":2.485,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"job-chaining-vs-fan-out-fan-in","title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["chaining","fan-out","fan-in","batching"]},"prevItem":{"title":"New Laravel Workflow Feature: Side Effects","permalink":"/blog/new-laravel-workflow-feature-side-effects"},"nextItem":{"title":"Waterline: Elegant UI for Laravel Workflows","permalink":"/blog/waterline-ui"}},"content":"[Chaining](https://laravel.com/docs/9.x/queues#job-chaining) is a workflow design pattern that involves the sequential execution of a series of activities, with the output of one activity potentially serving as the input to the next activity in the chain. This pattern is often used to create a linear, step-by-step process for completing a task.\\n\\n![chaining](https://miro.medium.com/max/1400/1*DOzdRnmC8Sq2w509yK1meg.webp)\\n\\nIn contrast, the fan-out/fan-in pattern involves dividing a task into smaller sub-tasks and then combining the results of those sub-tasks to produce the final result. This pattern is often used to parallelize a task and improve its performance by leveraging the power of multiple queue workers.\\n\\n![fan-out/fan-in](https://miro.medium.com/max/1154/1*g-0m-NWockKX_xbWXEjC1A.webp)\\n\\nThere are two phases: fan-out and fan-in.\\n\\nIn the fan-out phase, the workflow divides the main task into smaller sub-tasks and assigns each of those sub-tasks to a different activity. In the fan-in phase, the workflow collects the results of the activities and combines them to produce the final result.\\n\\nThe below workflow represents a simple example of a fan-out/fan-in pattern in which multiple activities are executed in parallel and their results are then merged together.\\n\\nThe workflow divides the task of creating a PDF into activities, with each activity responsible for rendering a single page of the document. Once the individual pages have been rendered, the fan-in phase of the workflow combines the rendered pages into a single PDF document.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass BuildPDFWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        $page1 = ActivityStub::make(ConvertURLActivity::class, \'https://example.com/\');\\n        $page2 = ActivityStub::make(ConvertURLActivity::class, \'https://example.com/\');\\n\\n        $pages = yield ActivityStub::all([$page1, $page2]);\\n\\n        $result = yield ActivityStub::make(MergePDFActivity::class, $pages);\\n\\n        return $result;\\n    }\\n}\\n```\\n\\nThe `ConvertURLActivity` is passed a URL as an argument, and it converts the contents of that URL into a PDF document. Because two separate activities are created, this results in the execution of two instances of `ConvertURLActivity` in parallel.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertURLActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        $fileName = uniqid() . \'.pdf\';\\n\\n        Http::withHeaders([\\n            \'Apikey\' => \'YOUR-API-KEY-GOES-HERE\',\\n        ])\\n        ->withOptions([\\n            \'sink\' => storage_path($fileName),\\n        ])\\n        ->post(\'https://api.cloudmersive.com/convert/web/url/to/pdf\', [\\n            \'Url\' => $url,\\n        ]);\\n\\n        return $fileName;\\n    }\\n}\\n```\\n\\nNext, the `BuildPDFWorkflow` uses `ActivityStub::all` to wait for both `ConvertURLActivity` instances to complete. This is an example of the fan-in part of the fan-out/fan-in pattern, as it collects the results of the parallel activities and combines them into a single array of PDF files.\\n\\nFinally, the `BuildPDFWorkflow` executes the`MergePDFActivity`, which is passed the array of PDFs that were generated by the `ConvertURLActivity` instances, and merges them into a single PDF document.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse setasign\\\\Fpdi\\\\Fpdi;\\nuse Workflow\\\\Activity;\\n\\nclass MergePDFActivity extends Activity\\n{\\n    public function execute($pages)\\n    {\\n        $fileName = uniqid() . \'.pdf\';\\n\\n        $pdf = new Fpdi();\\n\\n        foreach ($pages as $page) {\\n            $pdf->AddPage();\\n            $pdf->setSourceFile(storage_path($page));\\n            $pdf->useTemplate($pdf->importPage(1));\\n        }\\n\\n        $pdf->Output(\'F\', storage_path($fileName));\\n\\n        foreach ($pages as $page) {\\n            unlink(storage_path($page));\\n        }\\n\\n        return $fileName;\\n    }\\n}\\n```\\n\\nThis is what the final PDF looks like\u2026\\n\\n![merged PDF](https://miro.medium.com/max/1400/1*A3PKGEk8JptFIxB9IqCh6w.webp)\\n\\nOverall, using the fan-out/fan-in pattern in this way can significantly reduce the time it takes to create a PDF document, making the process more efficient and scalable.\\n\\nThanks for reading!"},{"id":"waterline-ui","metadata":{"permalink":"/blog/waterline-ui","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-19-waterline-ui.md","source":"@site/blog/2022-11-19-waterline-ui.md","title":"Waterline: Elegant UI for Laravel Workflows","description":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!","date":"2022-11-19T00:00:00.000Z","formattedDate":"November 19, 2022","tags":[{"label":"ui","permalink":"/blog/tags/ui"},{"label":"horizon","permalink":"/blog/tags/horizon"},{"label":"queues","permalink":"/blog/tags/queues"},{"label":"workflows","permalink":"/blog/tags/workflows"}],"readingTime":1.45,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"waterline-ui","title":"Waterline: Elegant UI for Laravel Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["ui","horizon","queues","workflows"]},"prevItem":{"title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","permalink":"/blog/job-chaining-vs-fan-out-fan-in"},"nextItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"}},"content":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!\\n\\n![dashboard](https://miro.medium.com/max/1400/1*2FP4crjpM8C48kAnqAjv5A.webp)\\n\\nLook familiar? Yes, this is shamelessly based on Horizon! However, the similarity is only superficial. Waterline is geared towards workflows, not queues. In fact, Horizon is still the best way to monitor your queues and plays along nicely with it.\\n\\n> Waterline is to workflows what Horizon is to queues.\\n\\n![workflow view](https://miro.medium.com/max/1400/1*EKWNNFy6kYRrqMbaozA8IQ.webp)\\n\\nAt this point you can see a lot of differences! You can see the arguments passed to the workflow and the output from the completed workflow. You can see a timeline that shows each activity at a glance along with any exceptions that were thrown. There is also a list view for the activities and their results.\\n\\nAt the bottom are any exceptions thrown, including a stack trace and a snippet of code showing the exact line. This makes debugging a breeze.\\n\\nIf you\u2019re familiar with Horizon then installing Waterline will be like d\xe9j\xe0 vu but the setup is simpler because Waterline doesn\u2019t care about queues, only workflows.\\n\\n## Installation\\n\\nYou can find the official [documentation](https://github.com/laravel-workflow/waterline) here but setup is simple.\\n\\n```bash\\ncomposer require laravel-workflow/waterline  \\n  \\nphp artisan waterline:publish\\n```\\n\\nThat\u2019s it! Now you should be able to view the `/waterline` URL in your app. By default this URL is only available in local environments. To view this outside of local environments you will have to modify the `WaterlineServiceProvider`.\\n\\n```php\\nGate::define(\'viewWaterline\', function ($user) {  \\n    return in_array($user->email, [  \\n        \'admin@example.com\',  \\n    ]);  \\n});\\n```\\n\\nThis will allow only the single admin user to access the Waterline UI.\\n\\nIf you want more context for the workflow that is show in the screenshot above, make sure to read my [previous article](https://medium.com/@laravel-workflow/email-verifications-using-laravel-workflow-acd6707aa7b3).\\n\\nThanks for reading!"},{"id":"invalidating-cloud-images","metadata":{"permalink":"/blog/invalidating-cloud-images","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-15-invalidating-cloud-images.md","source":"@site/blog/2022-11-15-invalidating-cloud-images.md","title":"Invalidating Cloud Images in Laravel with Workflows","description":"Many services like Cloud Image offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.","date":"2022-11-15T00:00:00.000Z","formattedDate":"November 15, 2022","tags":[{"label":"cache","permalink":"/blog/tags/cache"},{"label":"invalidation","permalink":"/blog/tags/invalidation"},{"label":"cloud","permalink":"/blog/tags/cloud"},{"label":"images","permalink":"/blog/tags/images"}],"readingTime":2.875,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"invalidating-cloud-images","title":"Invalidating Cloud Images in Laravel with Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["cache","invalidation","cloud","images"]},"prevItem":{"title":"Waterline: Elegant UI for Laravel Workflows","permalink":"/blog/waterline-ui"},"nextItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"Many services like [Cloud Image](https://docs.cloudimage.io/go/cloudimage-documentation-v7/en/caching-acceleration/invalidation-api) offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.\\n\\nHowever, it can be challenging if you want to automate this and also ensure that the image has been invalidated. This is because most invalidation APIs are asynchronous. When you request an image to be cleared from the cache, the API will return a response immediately. Then the actual process to clear the image from the cache runs in the background, sometimes taking up to 30 seconds before the image is updated. You could simply trust that the process works but it is also possible to be 100% sure with an automated workflow.\\n\\nThe workflow we need to write is as follows:\\n\\n1.  Check the currently cached image\u2019s timestamp via HEAD call\\n2.  Invalidate cached image via API call\\n3.  Check if the image timestamp has changed\\n4.  If not, wait a while and check again\\n5.  After 3 failed checks, go back to step 2\\n\\nThe workflow consists of two activities. The first activity gets the current timestamp of the image. This timestamp is used to determine if the image was actually cleared from the cache or not.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass CheckImageDateActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        return Http::head(\'https://\' . config(\'services.cloudimage.token\') . \'.cloudimg.io/\' . $url)\\n            ->header(\'date\');\\n    }\\n}\\n```\\n\\nThe second activity makes the actual call to Cloud Image\u2019s API to invalidate the image from the cache.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass InvalidateCacheActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        Http::withHeaders([\\n            \'X-Client-key\' => config(\'services.cloudimage.key\'),\\n            \'Content-Type\' => \'application/json\'\\n        ])->post(\'https://api.cloudimage.com/invalidate\', [\\n            \'scope\' => \'original\',\\n            \'urls\' => [\\n                \'/\' . $url\\n            ],\\n        ]);\\n    }\\n}\\n```\\n\\nThe workflow looks as follows and is the same process as outlined before.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass InvalidateCacheWorkflow extends Workflow\\n{\\n    public function execute($url)\\n    {\\n        $oldDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n        while (true) {\\n            yield ActivityStub::make(InvalidateCacheActivity::class, $url);\\n\\n            for ($i = 0; $i < 3; ++$i) { \\n                yield WorkflowStub::timer(30);\\n\\n                $newDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n                if ($oldDate !== $newDate) return;    \\n            }\\n        }\\n    }\\n}\\n```\\n\\nLine 13 uses an activity to get the current timestamp of the image we want to invalidate from the cache.\\n\\nLine 15 starts a loop that only exits when the image timestamp has changed.\\n\\nLine 16 uses an activity to invalidate the image from the cache.\\n\\nLine 18 starts a loop that tries a maximum of three times to first sleep and then check if the image timestamp has change, after three times the loop restarts at line 15.\\n\\nLine 19 sleeps the workflow for 30 seconds. This gives Cloud Image time to clear the image from their cache before checking the timestamp again.\\n\\nLines 21\u201323 reuse the activity from earlier to get the current timestamp of the cached image and compare it to the one saved on line 13. If the timestamps don\u2019t match then the image has successfully been cleared from the cache and we can exit the workflow. Otherwise, after three attempts, we start the process over again.\\n\\nThis is how the workflow execution looks in the queue assuming no retries are needed.\\n\\n![workflow execution](https://miro.medium.com/max/1400/1*7psZLD9mKGJnzEw508oIAw.webp)\\n\\nThe added benefit is that your image is now cached again and will be fast for the next user! Thanks for reading!"},{"id":"converting-videos-with-ffmpeg","metadata":{"permalink":"/blog/converting-videos-with-ffmpeg","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-31-converting-videos-with-ffmpeg.md","source":"@site/blog/2022-10-31-converting-videos-with-ffmpeg.md","title":"Converting Videos with FFmpeg and Laravel Workflow","description":"FFmpeg is a free, open-source software project allowing you to record, convert and stream audio and video.","date":"2022-10-31T00:00:00.000Z","formattedDate":"October 31, 2022","tags":[{"label":"video","permalink":"/blog/tags/video"},{"label":"ffmpeg","permalink":"/blog/tags/ffmpeg"},{"label":"conversion","permalink":"/blog/tags/conversion"},{"label":"transcoding","permalink":"/blog/tags/transcoding"}],"readingTime":1.67,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"converting-videos-with-ffmpeg","title":"Converting Videos with FFmpeg and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["video","ffmpeg","conversion","transcoding"]},"prevItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"},"nextItem":{"title":"Email Verifications Using Laravel Workflow","permalink":"/blog/email-verifications"}},"content":"[FFmpeg](https://ffmpeg.org/) is a free, open-source software project allowing you to record, convert and stream audio and video.\\n\\n[Laravel Queues](https://laravel.com/docs/9.x/queues) are great for long running tasks. Converting video takes a long time! With [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow), you can harness the power of queues to convert videos in the background and easily manage the process.\\n\\nRequirements\\n============\\n\\n1.  You\u2019ll need to [install FFmpeg](https://ffmpeg.org/download.html)\\n2.  Then `composer require php-ffmpeg/php-ffmpeg` ([docs](https://github.com/PHP-FFMpeg/PHP-FFMpeg#readme))\\n3.  Finally `composer require laravel-workflow/laravel-workflow` ([docs](https://github.com/laravel-workflow/laravel-workflow#laravel-workflow-))\\n\\nWorkflow\\n========\\n\\nA workflow is an easy way to orchestrate activities. A workflow that converts a video from one format to another might have several activities, such as downloading the video from storage, the actual conversion, and then finally notifying the user that it\u2019s finished.\\n\\nFor simplicity, the workflow we are making today will only contain the most interesting activity, converting the video.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass ConvertVideoWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        yield ActivityStub::make(\\n            ConvertVideoWebmActivity::class,\\n            storage_path(\'app/oceans.mp4\'),\\n            storage_path(\'app/oceans.webm\'),\\n        );\\n    }\\n}\\n```\\n\\nWe need a video to convert. We can use this one:\\n\\n[http://vjs.zencdn.net/v/oceans.mp4](http://vjs.zencdn.net/v/oceans.mp4)\\n\\nDownload it and save it to your app storage folder.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse FFMpeg\\\\FFMpeg;\\nuse FFMpeg\\\\Format\\\\Video\\\\WebM;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertVideoWebmActivity extends Activity\\n{\\n    public $timeout = 5;\\n\\n    public function execute($input, $output)\\n    {\\n        $ffmpeg = FFMpeg::create();\\n        $video = $ffmpeg->open($input);\\n        $format = new WebM();\\n        $format->on(\'progress\', fn () => $this->heartbeat());\\n        $video->save($format, $output);\\n    }\\n}\\n```\\n\\nThe activity converts any input video into a [WebM](https://www.webmproject.org/) output video. While ffmpeg is converting the video, a progress callback is triggered which in turn heartbeats the activity.\\n\\nThis is necessary because we have set a reasonable timeout of 5 seconds but we also have no idea how long it will take to convert the video. As long as we send a heartbeat at least once every 5 seconds, the activity will not timeout.\\n\\n![heartbeat](https://miro.medium.com/max/1400/1*ccrxeOEZYQciDYEprRKWiQ.webp)\\n\\n![no heartbeat](https://miro.medium.com/max/1400/1*9ZF3LTqjf4qsVcNVX5LK0A.webp)\\n\\nWithout a heartbeat, the worker will be killed after the timeout of 5 seconds is reached.\\n\\nTo actually run the workflow you just need to call:\\n\\n```php\\nWorkflowStub::make(ConvertVideoWorkflow::class)->start();\\n```\\n\\nAnd that\u2019s it!"},{"id":"email-verifications","metadata":{"permalink":"/blog/email-verifications","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-29-email-verifications.md","source":"@site/blog/2022-10-29-email-verifications.md","title":"Email Verifications Using Laravel Workflow","description":"A typical registration process goes as follows:","date":"2022-10-29T00:00:00.000Z","formattedDate":"October 29, 2022","tags":[{"label":"emails","permalink":"/blog/tags/emails"},{"label":"verification","permalink":"/blog/tags/verification"},{"label":"signed-urls","permalink":"/blog/tags/signed-urls"}],"readingTime":4.42,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"email-verifications","title":"Email Verifications Using Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["emails","verification","signed-urls"]},"prevItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"A typical registration process goes as follows:\\n\\n1.  User fills out registration form and submits it\\n2.  Laravel creates user in database with null `email_verified_at`\\n3.  Laravel sends email with a code, or a link back to our website\\n4.  User enters code, or clicks link\\n5.  Laravel sets `email_verified_at` to the current time\\n\\nWhat\u2019s wrong with this? Nothing. But like all things, as soon as real world complexity creeps in, this pattern could become painful. What if you wanted to send an email after the code or link expires? And do you really need a user in your database if they never verify their email address?\\n\\nLet\u2019s take this trivial example and replace it with a workflow. This is based on the [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library.\\n\\nGet Started\\n===========\\n\\nCreate a standard Laravel application and create the following files. First, the API routes.\\n\\n```php\\nuse App\\\\Workflows\\\\VerifyEmail\\\\VerifyEmailWorkflow;\\nuse Illuminate\\\\Support\\\\Facades\\\\Hash;\\nuse Illuminate\\\\Support\\\\Facades\\\\Route;\\nuse Workflow\\\\WorkflowStub;\\n\\nRoute::get(\'/register\', function () {\\n    $workflow = WorkflowStub::make(VerifyEmailWorkflow::class);\\n\\n    $workflow->start(\\n        \'test+1@example.com\',\\n        Hash::make(\'password\'),\\n    );\\n\\n    return response()->json([\\n        \'workflow_id\' => $workflow->id(),\\n    ]);\\n});\\n\\nRoute::get(\'/verify-email\', function () {\\n    $workflow = WorkflowStub::load(request(\'workflow_id\'));\\n\\n    $workflow->verify();\\n\\n    return response()->json(\'ok\');\\n})->name(\'verify-email\');\\n```\\n\\nThe `register` route creates a new `VerifyEmailWorkflow` , passes in the email and password, and then starts the workflow. Notice that we hash the password before giving it to the workflow. This prevents the plain text from being stored in the workflow logs.\\n\\nThe `verify-email` route receives a workflow id, loads it and then calls the `verify()` signal method.\\n\\nNow let\u2019s take a look at the actual workflow.\\n\\n```php\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\SignalMethod;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass VerifyEmailWorkflow extends Workflow\\n{\\n    private bool $verified = false;\\n\\n    #[SignalMethod]\\n    public function verify()\\n    {\\n        $this->verified = true;\\n    }\\n\\n    public function execute($email = \'\', $password = \'\')\\n    {\\n        yield ActivityStub::make(SendEmailVerificationEmailActivity::class, $email);\\n\\n        yield WorkflowStub::await(fn () => $this->verified);\\n\\n        yield ActivityStub::make(VerifyEmailActivity::class, $email, $password);\\n    }\\n}\\n```\\n\\nTake notice of the `yield` keywords. Because PHP (and most other languages) cannot save their execution state, coroutines rather than normal functions are used inside of workflows (but not activities). A coroutine will be called multiple times in order to execute to completion.\\n\\n![graph](https://miro.medium.com/max/1400/1*6eE2Gll61IbAAU85Md75OQ.webp)\\n\\nEven though this workflow will execute to completion effectively once, it will still be partially executed four different times. The results of activities are cached so that only failed activities will be called again. Successful activities get skipped.\\n\\nBut notice that any code we write between these calls will be called multiple times. That\u2019s why your code needs to be **deterministic** inside of workflow methods! If your code has four executions, each at different times, they must still all behave the same. There are no such limitations within activity methods.\\n\\nStep By Step\\n============\\n\\nThe first time the workflow executes, it will reach the call to `SendEmailVerificationEmailActivity` , start that activity, and then exit. Workflows suspend execution while an activity is running. After the `SendEmailVerificationEmailActivity` finishes, it will resume execution of the workflow. This brings us to\u2026\\n\\nThe second time the workflow is executed, it will reach the call to `SendEmailVerificationEmailActivity` and skip it because it will already have the result of that activity. Then it will reach the call to `WorkflowStub::await()` which allows the workflow to wait for an external signal. In this case, it will come from the user clicking on the verification link they receive in their email. Once the workflow is signaled then it will execute for\u2026\\n\\nThe third time, both the calls to `SendEmailVerificationEmailActivity` and `WorkflowStub::await()` are skipped. This means that the `VerifyEmailActivity` will be started. After the final activity has executed we still have\u2026\\n\\nThe final time the workflow is called, there is nothing left to do so the workflow completes.\\n\\nNow let\u2019s take a look at the activities.\\n\\nThe first activity just sends the user an email.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Mail\\\\VerifyEmail;\\nuse Illuminate\\\\Support\\\\Facades\\\\Mail;\\nuse Workflow\\\\Activity;\\n\\nclass SendEmailVerificationEmailActivity extends Activity\\n{\\n    public function execute($email)\\n    {\\n        Mail::to($email)->send(new VerifyEmail($this->workflowId()));\\n    }\\n}\\n```\\n\\nThe email contains a temporary signed URL that includes the workflow ID.\\n\\n```php\\nnamespace App\\\\Mail;\\n\\nuse Illuminate\\\\Bus\\\\Queueable;\\nuse Illuminate\\\\Mail\\\\Mailable;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Content;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Envelope;\\nuse Illuminate\\\\Queue\\\\SerializesModels;\\nuse Illuminate\\\\Support\\\\Facades\\\\URL;\\n\\nclass VerifyEmail extends Mailable\\n{\\n    use Queueable, SerializesModels;\\n\\n    private $workflowId;\\n\\n    public function __construct($workflowId)\\n    {\\n        $this->workflowId = $workflowId;\\n    }\\n\\n    public function envelope()\\n    {\\n        return new Envelope(\\n            subject: \'Verify Email\',\\n        );\\n    }\\n\\n    public function content()\\n    {\\n        return new Content(\\n            view: \'emails.verify-email\',\\n            with: [\\n                \'url\' => URL::temporarySignedRoute(\\n                    \'verify-email\',\\n                    now()->addMinutes(30),\\n                    [\'workflow_id\' => $this->workflowId],\\n                ),\\n            ],\\n        );\\n    }\\n\\n    public function attachments()\\n    {\\n        return [];\\n    }\\n}\\n```\\n\\nThe user gets the URL in a clickable link.\\n\\n```\\n<a href=\\"{{ $url }}\\">verification link</a>\\n```\\n\\nThis link takes the user to the `verify-email` route from our API routes, which will then start the final activity.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Models\\\\User;\\nuse Workflow\\\\Activity;\\n\\nclass VerifyEmailActivity extends Activity\\n{\\n    public function execute($email, $password)\\n    {\\n        $user = new User();\\n        $user->name = \'\';\\n        $user->email = $email;\\n        $user->email_verified_at = now();\\n        $user->password = $password;\\n        $user->save();\\n    }\\n}\\n```\\n\\nWe have created the user and verified their email address at the same time. Neat!\\n\\nWrapping Up\\n===========\\n\\nIf we take a look at the output of `php artisan queue:work` we can better see how the workflow and individual activities are interleaved.\\n\\n![queue worker](https://miro.medium.com/max/1400/1*q6-r41SN-uWfzp6p7Z4r8g.webp)\\n\\nWe can see the four different executions of the workflow, the individual activities and the signal we sent.\\n\\nThe [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library is heavily inspired by [Temporal](https://temporal.io/) but powered by [Laravel Queues](https://laravel.com/docs/9.x/queues).\\n\\nThanks for reading!"}]}')}}]);