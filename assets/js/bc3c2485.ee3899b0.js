"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[3257],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var i=n.createContext({}),p=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},c="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},w=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(r),w=o,m=c["".concat(i,".").concat(w)]||c[w]||k[w]||a;return r?n.createElement(m,l(l({ref:t},u),{},{components:r})):n.createElement(m,l({ref:t},u))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,l=new Array(a);l[0]=w;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[c]="string"==typeof e?e:o,l[1]=s;for(var p=2;p<a;p++)l[p]=r[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}w.displayName="MDXCreateElement"},8570:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(7462),o=(r(7294),r(3905));const a={slug:"laravel-workflows-as-mcp-tools-for-ai-clients",title:"Workflows as MCP Tools for AI Clients",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png"},tags:["ai","workflow","mcp","agents","tools"]},l=void 0,s={permalink:"/blog/laravel-workflows-as-mcp-tools-for-ai-clients",editUrl:"https://github.com/durable-workflow/durable-workflow.github.io/edit/main/blog/2025-12-03-laravel-workflows-as-mcp-tools-for-ai-clients.md",source:"@site/blog/2025-12-03-laravel-workflows-as-mcp-tools-for-ai-clients.md",title:"Workflows as MCP Tools for AI Clients",description:"The Model Context Protocol (MCP) is rapidly becoming the standard way for AI assistants like Claude, ChatGPT, and GitHub Copilot to interact with external tools and services. With Laravel MCP, you can expose your Workflow processes as callable tools that any MCP-compatible AI client can discover, invoke, and monitor.",date:"2025-12-03T00:00:00.000Z",formattedDate:"December 3, 2025",tags:[{label:"ai",permalink:"/blog/tags/ai"},{label:"workflow",permalink:"/blog/tags/workflow"},{label:"mcp",permalink:"/blog/tags/mcp"},{label:"agents",permalink:"/blog/tags/agents"},{label:"tools",permalink:"/blog/tags/tools"}],readingTime:7.75,hasTruncateMarker:!1,authors:[{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"}],frontMatter:{slug:"laravel-workflows-as-mcp-tools-for-ai-clients",title:"Workflows as MCP Tools for AI Clients",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"},tags:["ai","workflow","mcp","agents","tools"]},nextItem:{title:"Building Reliable Agentic Loops with Workflow and PrismPHP",permalink:"/blog/building-reliable-agentic-loops-with-laravel-workflow-and-prismphp"}},i={authorsImageUrls:[void 0]},p=[{value:"Why MCP + Workflow?",id:"why-mcp--workflow",level:3},{value:"What We&#39;re Building",id:"what-were-building",level:3},{value:"Step-by-Step Implementation",id:"step-by-step-implementation",level:3},{value:"1. Install Laravel MCP",id:"1-install-laravel-mcp",level:4},{value:"2. Create the MCP Server",id:"2-create-the-mcp-server",level:4},{value:"3. Create the Start Workflow Tool",id:"3-create-the-start-workflow-tool",level:4},{value:"4. Create the Get Result Tool",id:"4-create-the-get-result-tool",level:4},{value:"5. Create the List Workflows Tool",id:"5-create-the-list-workflows-tool",level:4},{value:"6. Configure Available Workflows",id:"6-configure-available-workflows",level:4},{value:"7. Register the MCP Server",id:"7-register-the-mcp-server",level:4},{value:"Connecting AI Clients",id:"connecting-ai-clients",level:3},{value:"VS Code / GitHub Copilot",id:"vs-code--github-copilot",level:4},{value:"Real-World Usage",id:"real-world-usage",level:3},{value:"What Makes This Pattern Powerful",id:"what-makes-this-pattern-powerful",level:3},{value:"Try It Now in Your Browser",id:"try-it-now-in-your-browser",level:3},{value:"Where to Go From Here",id:"where-to-go-from-here",level:3}],u={toc:p};function c(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The Model Context Protocol (MCP) is rapidly becoming the standard way for AI assistants like Claude, ChatGPT, and GitHub Copilot to interact with external tools and services. With Laravel MCP, you can expose your Workflow processes as callable tools that any MCP-compatible AI client can discover, invoke, and monitor."),(0,o.kt)("p",null,"In this post, we'll show how to build an MCP server that allows AI clients to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Discover available workflows"),(0,o.kt)("li",{parentName:"ul"},"Start workflows asynchronously"),(0,o.kt)("li",{parentName:"ul"},"Poll for status and retrieve results")),(0,o.kt)("p",null,"This creates a powerful pattern where AI agents can orchestrate long-running, durable workflows, perfect for complex tasks that can't complete in a single request."),(0,o.kt)("h3",{id:"why-mcp--workflow"},"Why MCP + Workflow?"),(0,o.kt)("p",null,"Workflow excels at durable, stateful execution. MCP excels at giving AI clients structured access to external capabilities. Together, they enable:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Async AI operations"),": Start a workflow, continue the conversation, check results later"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Reliable execution"),": Workflows survive crashes, retries, and long wait times"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Observability"),": Track every workflow through Waterline's dashboard"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Stateless servers"),": The MCP server doesn't hold state. Clients track workflow IDs")),(0,o.kt)("p",null,'This mirrors how humans delegate tasks: "Start this report, I\'ll check back later."'),(0,o.kt)("h3",{id:"what-were-building"},"What We're Building"),(0,o.kt)("p",null,"We'll create an MCP server with three tools:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Tool"),(0,o.kt)("th",{parentName:"tr",align:null},"Purpose"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"list_workflows")),(0,o.kt)("td",{parentName:"tr",align:null},"Discover available workflows and view recent runs")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"start_workflow")),(0,o.kt)("td",{parentName:"tr",align:null},"Start a workflow and get a tracking ID")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"get_workflow_result")),(0,o.kt)("td",{parentName:"tr",align:null},"Check status and retrieve output when complete")))),(0,o.kt)("h3",{id:"step-by-step-implementation"},"Step-by-Step Implementation"),(0,o.kt)("h4",{id:"1-install-laravel-mcp"},"1. Install Laravel MCP"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"composer require laravel/mcp\nphp artisan vendor:publish --tag=ai-routes\n")),(0,o.kt)("p",null,"This gives you ",(0,o.kt)("inlineCode",{parentName:"p"},"routes/ai.php")," where you'll register your MCP server."),(0,o.kt)("h4",{id:"2-create-the-mcp-server"},"2. Create the MCP Server"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:mcp-server WorkflowServer\n")),(0,o.kt)("p",null,"Configure it with instructions for the AI:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Mcp\\Servers;\n\nuse App\\Mcp\\Tools\\GetWorkflowResultTool;\nuse App\\Mcp\\Tools\\ListWorkflowsTool;\nuse App\\Mcp\\Tools\\StartWorkflowTool;\nuse Laravel\\Mcp\\Server;\n\nclass WorkflowServer extends Server\n{\n    protected string $name = 'Workflow Server';\n    protected string $version = '1.0.0';\n\n    protected string $instructions = <<<'MARKDOWN'\n        This server allows you to start and monitor Workflows.\n\n        ## Typical Usage Pattern\n\n        1. Call `list_workflows` to see what workflows are available.\n        2. Call `start_workflow` with the workflow name and arguments.\n        3. Store the returned `workflow_id`.\n        4. Call `get_workflow_result` until status is `WorkflowCompletedStatus`.\n        5. Read the `output` field for the result.\n\n        ## Status Values\n\n        - `WorkflowCreatedStatus` - Workflow has been created\n        - `WorkflowPendingStatus` - Queued for execution\n        - `WorkflowRunningStatus` - Currently executing\n        - `WorkflowWaitingStatus` - Waiting (timer, signal, etc.)\n        - `WorkflowCompletedStatus` - Finished successfully\n        - `WorkflowFailedStatus` - Encountered an error\n    MARKDOWN;\n\n    protected array $tools = [\n        ListWorkflowsTool::class,\n        StartWorkflowTool::class,\n        GetWorkflowResultTool::class,\n    ];\n}\n")),(0,o.kt)("h4",{id:"3-create-the-start-workflow-tool"},"3. Create the Start Workflow Tool"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:mcp-tool StartWorkflowTool\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Mcp\\Tools;\n\nuse Illuminate\\Contracts\\JsonSchema\\JsonSchema;\nuse Illuminate\\Support\\Arr;\nuse Laravel\\Mcp\\Request;\nuse Laravel\\Mcp\\Response;\nuse Laravel\\Mcp\\Server\\Tool;\nuse Workflow\\Workflow;\nuse Workflow\\WorkflowStub;\n\nclass StartWorkflowTool extends Tool\n{\n    protected string $description = <<<'MARKDOWN'\n        Start a Workflow asynchronously and return its workflow ID.\n        \n        The workflow will execute in the background on the queue. Use the\n        `get_workflow_result` tool to poll for status and retrieve results\n        once the workflow completes.\n    MARKDOWN;\n\n    public function handle(Request $request): Response\n    {\n        $data = $request->validate([\n            'workflow' => ['required', 'string'],\n            'args' => ['nullable', 'array'],\n            'external_id' => ['nullable', 'string', 'max:255'],\n        ]);\n\n        $workflowKey = $data['workflow'];\n        $args = Arr::get($data, 'args', []);\n        $externalId = $data['external_id'] ?? null;\n\n        $workflowClass = $this->resolveWorkflowClass($workflowKey);\n\n        if ($workflowClass === null) {\n            return Response::error(\"Unknown workflow: {$workflowKey}\");\n        }\n\n        if (! class_exists($workflowClass) || ! is_subclass_of($workflowClass, Workflow::class)) {\n            return Response::error(\"Invalid workflow class: {$workflowClass}\");\n        }\n\n        $stub = WorkflowStub::make($workflowClass);\n        $stub->start(...array_values($args));\n\n        $status = $stub->status();\n        $statusName = is_object($status) ? class_basename($status) : class_basename((string) $status);\n\n        return Response::json([\n            'workflow_id' => $stub->id(),\n            'workflow' => $workflowKey,\n            'status' => $statusName,\n            'external_id' => $externalId,\n            'message' => 'Workflow started. Use get_workflow_result to poll status.',\n        ]);\n    }\n\n    protected function resolveWorkflowClass(string $key): ?string\n    {\n        $mapped = config(\"workflow_mcp.workflows.{$key}\");\n        if ($mapped !== null) {\n            return $mapped;\n        }\n\n        if (config('workflow_mcp.allow_fqcn', false) && str_contains($key, '\\\\')) {\n            return $key;\n        }\n\n        return null;\n    }\n\n    public function schema(JsonSchema $schema): array\n    {\n        $workflows = implode(', ', array_keys(config('workflow_mcp.workflows', [])));\n\n        return [\n            'workflow' => $schema->string()\n                ->description(\"The workflow to start. Available: {$workflows}\"),\n            'args' => $schema->object()\n                ->description('Arguments for the workflow execute() method.'),\n            'external_id' => $schema->string()\n                ->description('Optional idempotency key for tracking.'),\n        ];\n    }\n}\n")),(0,o.kt)("h4",{id:"4-create-the-get-result-tool"},"4. Create the Get Result Tool"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:mcp-tool GetWorkflowResultTool\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Mcp\\Tools;\n\nuse App\\Models\\StoredWorkflow;\nuse Illuminate\\Contracts\\JsonSchema\\JsonSchema;\nuse Laravel\\Mcp\\Request;\nuse Laravel\\Mcp\\Response;\nuse Laravel\\Mcp\\Server\\Tool;\nuse Workflow\\States\\WorkflowCompletedStatus;\nuse Workflow\\States\\WorkflowFailedStatus;\nuse Workflow\\WorkflowStub;\n\nclass GetWorkflowResultTool extends Tool\n{\n    protected string $description = <<<'MARKDOWN'\n        Fetch the status and, if completed, the output of a Workflow.\n        \n        Use the workflow_id returned by `start_workflow` to check progress.\n        Once status is `WorkflowCompletedStatus`, the output field contains the result.\n    MARKDOWN;\n\n    public function handle(Request $request): Response\n    {\n        $data = $request->validate([\n            'workflow_id' => ['required'],\n        ]);\n\n        $workflowId = $data['workflow_id'];\n        $stored = StoredWorkflow::find($workflowId);\n\n        if (! $stored) {\n            return Response::json([\n                'found' => false,\n                'message' => \"Workflow {$workflowId} not found.\",\n            ]);\n        }\n\n        $workflow = WorkflowStub::load($workflowId);\n        $status = $workflow->status();\n        $statusName = is_object($status) ? class_basename($status) : class_basename((string) $status);\n        $running = $workflow->running();\n\n        $result = null;\n        $error = null;\n\n        if (! $running && str_contains($statusName, 'Completed')) {\n            $result = $workflow->output();\n        }\n\n        if (! $running && str_contains($statusName, 'Failed')) {\n            $exception = $stored->exceptions()->latest()->first();\n            $error = $exception?->exception ?? 'Unknown error';\n        }\n\n        return Response::json([\n            'found' => true,\n            'workflow_id' => $workflowId,\n            'status' => $statusName,\n            'running' => $running,\n            'output' => $result,\n            'error' => $error,\n            'created_at' => $stored->created_at?->toIso8601String(),\n            'updated_at' => $stored->updated_at?->toIso8601String(),\n        ]);\n    }\n\n    public function schema(JsonSchema $schema): array\n    {\n        return [\n            'workflow_id' => $schema->string()\n                ->description('The workflow ID returned by start_workflow.'),\n        ];\n    }\n}\n")),(0,o.kt)("h4",{id:"5-create-the-list-workflows-tool"},"5. Create the List Workflows Tool"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:mcp-tool ListWorkflowsTool\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Mcp\\Tools;\n\nuse App\\Models\\StoredWorkflow;\nuse Illuminate\\Contracts\\JsonSchema\\JsonSchema;\nuse Laravel\\Mcp\\Request;\nuse Laravel\\Mcp\\Response;\nuse Laravel\\Mcp\\Server\\Tool;\n\nclass ListWorkflowsTool extends Tool\n{\n    protected string $description = <<<'MARKDOWN'\n        List available workflow types and optionally show recent workflow runs.\n        \n        Use this to discover what workflows can be started, or to see\n        the status of recent executions.\n    MARKDOWN;\n\n    public function handle(Request $request): Response\n    {\n        $data = $request->validate([\n            'show_recent' => ['nullable', 'boolean'],\n            'limit' => ['nullable', 'integer', 'min:1', 'max:50'],\n            'status' => ['nullable', 'string'],\n        ]);\n\n        $showRecent = $data['show_recent'] ?? false;\n        $limit = $data['limit'] ?? 10;\n        $statusFilter = $data['status'] ?? null;\n\n        $availableWorkflows = [];\n        foreach (config('workflow_mcp.workflows', []) as $key => $class) {\n            $availableWorkflows[] = ['key' => $key, 'class' => $class];\n        }\n\n        $response = [\n            'available_workflows' => $availableWorkflows,\n        ];\n\n        if ($showRecent) {\n            $query = StoredWorkflow::query()\n                ->orderBy('created_at', 'desc')\n                ->limit($limit);\n\n            if ($statusFilter) {\n                $query->where('status', 'like', \"%{$statusFilter}%\");\n            }\n\n            $response['recent_workflows'] = $query->get()->map(function ($w) {\n                $status = $w->status;\n                $statusName = is_object($status) ? class_basename($status) : class_basename((string) $status);\n\n                return [\n                    'id' => $w->id,\n                    'class' => $w->class,\n                    'status' => $statusName,\n                    'created_at' => $w->created_at?->toIso8601String(),\n                ];\n            });\n        }\n\n        return Response::json($response);\n    }\n\n    public function schema(JsonSchema $schema): array\n    {\n        return [\n            'show_recent' => $schema->boolean()\n                ->description('Include recent workflow runs in response.'),\n            'limit' => $schema->integer()\n                ->description('Max recent workflows to return (default: 10).'),\n            'status' => $schema->string()\n                ->description('Filter by status (e.g., \"Completed\", \"Failed\").'),\n        ];\n    }\n}\n")),(0,o.kt)("h4",{id:"6-configure-available-workflows"},"6. Configure Available Workflows"),(0,o.kt)("p",null,"Create ",(0,o.kt)("inlineCode",{parentName:"p"},"config/workflow_mcp.php")," to whitelist which workflows AI clients can start:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"return [\n    'allow_fqcn' => env('WORKFLOW_MCP_ALLOW_FQCN', false),\n\n    'workflows' => [\n        'simple' => App\\Workflows\\Simple\\SimpleWorkflow::class,\n        'prism' => App\\Workflows\\Prism\\PrismWorkflow::class,\n    ],\n];\n")),(0,o.kt)("p",null,"This prevents arbitrary class execution. Only mapped workflows are accessible."),(0,o.kt)("h4",{id:"7-register-the-mcp-server"},"7. Register the MCP Server"),(0,o.kt)("p",null,"Update ",(0,o.kt)("inlineCode",{parentName:"p"},"routes/ai.php"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use App\\Mcp\\Servers\\WorkflowServer;\nuse Laravel\\Mcp\\Facades\\Mcp;\n\nMcp::web('/mcp/workflows', WorkflowServer::class);\n")),(0,o.kt)("h3",{id:"connecting-ai-clients"},"Connecting AI Clients"),(0,o.kt)("h4",{id:"vs-code--github-copilot"},"VS Code / GitHub Copilot"),(0,o.kt)("p",null,"Create ",(0,o.kt)("inlineCode",{parentName:"p"},".vscode/mcp.json")," in your project:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "servers": {\n    "laravel-workflow": {\n      "type": "http",\n      "url": "http://localhost/mcp/workflows"\n    }\n  }\n}\n')),(0,o.kt)("p",null,"This configuration works for both local development and GitHub Codespaces. In Codespaces, the VS Code server runs inside the container, so ",(0,o.kt)("inlineCode",{parentName:"p"},"localhost")," correctly reaches the Laravel server without needing public ports or the ",(0,o.kt)("inlineCode",{parentName:"p"},"*.app.github.dev")," URL."),(0,o.kt)("p",null,'After reloading VS Code (Cmd/Ctrl+Shift+P \u2192 "Developer: Reload Window"), Copilot can use the workflow tools directly in chat.'),(0,o.kt)("h3",{id:"real-world-usage"},"Real-World Usage"),(0,o.kt)("p",null,"Once connected, you can have natural conversations with your AI assistant:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"You:"),' "What workflows are available?"'),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"AI:")," ",(0,o.kt)("em",{parentName:"p"},"calls list_workflows"),' "I found 2 workflows: ',(0,o.kt)("inlineCode",{parentName:"p"},"simple")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"prism"),'."')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"You:"),' "Start the prism workflow"'),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"AI:")," ",(0,o.kt)("em",{parentName:"p"},"calls start_workflow"),' "Started workflow ID 42. I\'ll check its status."')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"AI:")," ",(0,o.kt)("em",{parentName:"p"},"calls get_workflow_result")," \"The workflow completed! Here's the generated user profile: { name: 'Elena', hobbies: ","[...]",' }"')),(0,o.kt)("p",null,"This creates a seamless experience where AI assistants can orchestrate complex, long-running operations while keeping the user informed."),(0,o.kt)("h3",{id:"what-makes-this-pattern-powerful"},"What Makes This Pattern Powerful"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Durability"),": Workflows survive server restarts and network failures"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Async by design"),": AI clients don't block waiting for completion"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Observable"),": Every workflow is tracked in Waterline's dashboard"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Secure"),": Whitelist-based workflow access prevents arbitrary execution"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Stateless MCP"),": The server holds no state. Clients track workflow IDs")),(0,o.kt)("h3",{id:"try-it-now-in-your-browser"},"Try It Now in Your Browser"),(0,o.kt)("p",null,"This MCP integration is included and pre-configured in the Workflow ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/laravel-workflow/sample-app"},"Sample App"),"."),(0,o.kt)("p",null,"To try it:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Open the sample-app repo on GitHub"),(0,o.kt)("li",{parentName:"ol"},"Click ",(0,o.kt)("strong",{parentName:"li"},"Code")," \u2192 ",(0,o.kt)("strong",{parentName:"li"},"Codespaces")," \u2192 ",(0,o.kt)("strong",{parentName:"li"},"Create codespace on main")),(0,o.kt)("li",{parentName:"ol"},"Wait for the environment to build"),(0,o.kt)("li",{parentName:"ol"},"Setup the app and start the queue worker:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan app:init\nphp artisan queue:work\n"))),(0,o.kt)("li",{parentName:"ol"},"Enable the Workflow Server MCP tools"),(0,o.kt)("li",{parentName:"ol"},"Ask your AI to list and run workflows!")),(0,o.kt)("h3",{id:"where-to-go-from-here"},"Where to Go From Here"),(0,o.kt)("p",null,"You can extend this pattern to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Parameterized workflows"),": Pass user input to workflow arguments"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Webhook notifications"),": Push completion events instead of polling"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Workflow signals"),": Let AI clients send signals to waiting workflows"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Progress streaming"),": Use SSE to stream workflow progress in real-time"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Multi-step agents"),": Chain multiple workflows together in a conversation")),(0,o.kt)("p",null,"The combination of Workflow's durable execution and MCP's tool protocol creates a foundation for truly capable AI agents that can handle real-world complexity."))}c.isMDXComponent=!0}}]);