"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[9444],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=o,m=c["".concat(s,".").concat(d)]||c[d]||h[d]||i;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1903:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={},r="Building a Durable AI Travel Agent with Laravel",l={permalink:"/blog/2026/02/07/building-a-durable-ai-travel-agent-with-laravel",editUrl:"https://github.com/durable-workflow/durable-workflow.github.io/edit/main/blog/2026-02-07-building-a-durable-ai-travel-agent-with-laravel.md",source:"@site/blog/2026-02-07-building-a-durable-ai-travel-agent-with-laravel.md",title:"Building a Durable AI Travel Agent with Laravel",description:"Look at these execution logs:",date:"2026-02-07T00:00:00.000Z",formattedDate:"February 7, 2026",tags:[],readingTime:13.93,hasTruncateMarker:!1,authors:[],frontMatter:{},nextItem:{title:"Workflows as MCP Tools for AI Clients",permalink:"/blog/laravel-workflows-as-mcp-tools-for-ai-clients"}},s={authorsImageUrls:[]},p=[{value:"The Problem",id:"the-problem",level:2},{value:"The Solution: Laravel AI SDK + Durable Workflows",id:"the-solution-laravel-ai-sdk--durable-workflows",level:2},{value:"Step 1: Create the Agent",id:"step-1-create-the-agent",level:3},{value:"Step 2: The Tools Pattern",id:"step-2-the-tools-pattern",level:3},{value:"Step 3: The Activity",id:"step-3-the-activity",level:3},{value:"The Workflow: Where It All Comes Together",id:"the-workflow-where-it-all-comes-together",level:2},{value:"The Inbox / Outbox Pattern",id:"the-inbox--outbox-pattern",level:3},{value:"Timeout as Business Logic",id:"timeout-as-business-logic",level:3},{value:"The Conversation Loop",id:"the-conversation-loop",level:3},{value:"The Saga Pattern: Star of the Show",id:"the-saga-pattern-star-of-the-show",level:3},{value:"What Just Happened",id:"what-just-happened",level:2},{value:"Without Sagas?",id:"without-sagas",level:2},{value:"Key Innovations",id:"key-innovations",level:2},{value:"The Traditional Approach",id:"the-traditional-approach",level:2},{value:"Observability",id:"observability",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Try It Now in Your Browser",id:"try-it-now-in-your-browser",level:3}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Look at these execution logs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"BookHotelActivity ........... RUNNING\nBooking hotel: Grand Hotel, Paris, 2026-03-01 to 2026-03-03, 1 guest(s). Confirmation #902928\nBookHotelActivity .......... 4.35ms DONE\n\nBookFlightActivity .......... RUNNING\nBookFlightActivity ......... 8.37ms FAIL\n\nCancelHotelActivity ......... RUNNING\nCancelling hotel Hotel booked: Grand Hotel, Paris, check-in 2026-03-01,\ncheck-out 2026-03-03, 1 guest(s). Confirmation #902928...\nCancelHotelActivity ....... 3.74ms DONE\n\nAiWorkflow ............... 10.96ms DONE\n")),(0,o.kt)("p",null,"Read that again. A user asked to book a hotel and a flight in a single message. The hotel went through. The flight failed. And the system ",(0,o.kt)("em",{parentName:"p"},"automatically cancelled the hotel using the original confirmation number"),". The user saw this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Agent: Flight booking failed: New York to Paris.\n       Any previous bookings have been cancelled.\n")),(0,o.kt)("p",null,"Distributed transaction management that just works."),(0,o.kt)("p",null,"This is a durable AI travel agent built with the Laravel AI SDK and Durable Workflow. It's one continuous conversation where every possible outcome is handled gracefully: successful bookings, partial failures, timeouts, and saga compensation, all in about 100 lines of workflow code."),(0,o.kt)("p",null,"Let's build it."),(0,o.kt)("h2",{id:"the-problem"},"The Problem"),(0,o.kt)("p",null,"Imagine you're tasked with building a conversational AI travel agent. Not a toy, a real one. Users chat with it, ask it to book hotels, flights, and rental cars, and expect it to handle failures gracefully."),(0,o.kt)("p",null,"Here's what you'd need with traditional Laravel patterns:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"State management.")," A ",(0,o.kt)("inlineCode",{parentName:"p"},"conversation_state")," table tracking where each user is in the flow. A state machine (or a mess of ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statements) to handle transitions. What happens if the user sends a message while a booking is in progress? What if two queue workers pick up the same conversation?"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Failure handling.")," An event listener on ",(0,o.kt)("inlineCode",{parentName:"p"},"BookingFailed"),". Another listener to figure out which previous bookings need to be cancelled. A database query to look up confirmation numbers. A job to call each cancellation API. Another listener in case the ",(0,o.kt)("em",{parentName:"p"},"cancellation")," fails."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Timeouts."),' A cron job that runs every minute, queries for "stale" conversations, and closes them. Edge cases when a user sends a message at the exact moment the cron job fires.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Cleanup.")," Scheduled commands to archive old conversations. Orphan detection for bookings that got confirmed but whose conversations crashed. Manual intervention scripts for the support team."),(0,o.kt)("p",null,"You're looking at 500+ lines of infrastructure code scattered across jobs, events, listeners, models, migrations, service classes, and cron configurations. And you haven't written a single line of business logic yet."),(0,o.kt)("p",null,"There's a better way."),(0,o.kt)("h2",{id:"the-solution-laravel-ai-sdk--durable-workflows"},"The Solution: Laravel AI SDK + Durable Workflows"),(0,o.kt)("p",null,"We're going to build this with three things:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Laravel AI SDK"),", for the conversational agent and tool calling"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Durable Workflow"),", for durable execution, saga compensation, and timeouts"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"About 100 lines of actual business logic"))),(0,o.kt)("h3",{id:"step-1-create-the-agent"},"Step 1: Create the Agent"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:agent TravelAgent\n")),(0,o.kt)("p",null,"And give it some tools:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan make:tool BookHotel\nphp artisan make:tool BookFlight\nphp artisan make:tool BookRentalCar\n")),(0,o.kt)("p",null,"The agent is straightforward:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"class TravelAgent implements Agent, Conversational, HasTools\n{\n    use Promptable;\n\n    private array $messages = [];\n\n    public function instructions(): Stringable|string\n    {\n        return <<<'INSTRUCTIONS'\n        You are a professional travel agent. Help users plan and book travel.\n\n        BOOKING RULES:\n        - When a user asks to book a hotel, flight, or rental car, ALWAYS call\n          the appropriate booking tool immediately with whatever details they\n          provided. Never ask for more details before calling the tool.\n        - Use reasonable defaults for any missing information (e.g. 1 guest,\n          next-day dates, economy class).\n        - You may call multiple booking tools in a single response if the user\n          requests multiple bookings.\n        - For flights, always include a return date if the user mentions round\n          trip, return dates, or trip end dates. Omit return_date only for\n          explicitly one-way flights.\n\n        CONVERSATION RULES:\n        - Be concise and action-oriented.\n        - After placing bookings, briefly confirm what was booked.\n        - You can also help with itinerary planning, destination advice,\n          packing lists, and general travel logistics.\n        INSTRUCTIONS;\n    }\n\n    public function continue($messages): static\n    {\n        $this->messages = $messages;\n\n        return $this;\n    }\n\n    public function messages(): iterable\n    {\n        return $this->messages;\n    }\n\n    public function tools(): iterable\n    {\n        return [\n            new BookHotel(),\n            new BookFlight(),\n            new BookRentalCar(),\n        ];\n    }\n}\n")),(0,o.kt)("p",null,"Notice we implement ",(0,o.kt)("inlineCode",{parentName:"p"},"Conversational")," but we don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"RemembersConversations"),". The workflow history is our conversation store. We pass it in through the ",(0,o.kt)("inlineCode",{parentName:"p"},"continue()")," method."),(0,o.kt)("h3",{id:"step-2-the-tools-pattern"},"Step 2: The Tools Pattern"),(0,o.kt)("p",null,"Here's the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookHotel")," tool:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"class BookHotel implements Tool\n{\n    public static array $pending = [];\n\n    public function description(): Stringable|string\n    {\n        return 'Book a hotel for the user.';\n    }\n\n    public function handle(Request $request): Stringable|string\n    {\n        self::$pending[] = [\n            'type' => 'book_hotel',\n            'hotel_name' => $request['hotel_name'],\n            'check_in_date' => $request['check_in_date'],\n            'check_out_date' => $request['check_out_date'],\n            'guests' => (int) $request['guests'],\n        ];\n\n        return 'Booking hotel: ' . $request['hotel_name'] . ' from '\n            . $request['check_in_date'] . ' to ' . $request['check_out_date']\n            . ' for ' . $request['guests'] . ' guest(s)';\n    }\n\n    public function schema(JsonSchema $schema): array\n    {\n        return [\n            'hotel_name' => $schema->string()->required()->description('The name and location of the hotel to book'),\n            'check_in_date' => $schema->string()->required()->description('Check-in date (YYYY-MM-DD)'),\n            'check_out_date' => $schema->string()->required()->description('Check-out date (YYYY-MM-DD)'),\n            'guests' => $schema->integer()->required()->description('Number of guests'),\n        ];\n    }\n}\n")),(0,o.kt)("p",null,"This is the key insight: ",(0,o.kt)("strong",{parentName:"p"},"the tool doesn't book anything"),". It collects structured data from the AI into a static ",(0,o.kt)("inlineCode",{parentName:"p"},"$pending")," array and returns a confirmation message to the agent. The actual booking happens later, inside the workflow, as a durable activity."),(0,o.kt)("p",null,"Why? Because tool calls happen inside the AI activity. If we booked the hotel directly in the tool's ",(0,o.kt)("inlineCode",{parentName:"p"},"handle()")," method, the workflow wouldn't know about it and couldn't compensate on failure. By collecting the requests and processing them in the workflow, every side effect is durable and reversible."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"BookFlight")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"BookRentalCar")," follow the same pattern."),(0,o.kt)("h3",{id:"step-3-the-activity"},"Step 3: The Activity"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TravelAgentActivity")," bridges the AI agent and the workflow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"class TravelAgentActivity extends Activity\n{\n    public function execute($messages)\n    {\n        BookHotel::$pending = [];\n        BookFlight::$pending = [];\n        BookRentalCar::$pending = [];\n\n        $history = array_slice($messages, 0, -1);\n        $currentUserMessage = end($messages);\n\n        $response = (new TravelAgent())\n            ->continue($history)\n            ->prompt($currentUserMessage->content);\n\n        $bookings = array_merge(\n            BookHotel::$pending,\n            BookFlight::$pending,\n            BookRentalCar::$pending,\n        );\n\n        return json_encode([\n            'text' => (string) $response,\n            'bookings' => $bookings,\n        ]);\n    }\n}\n")),(0,o.kt)("p",null,"It resets the pending arrays, passes the conversation history to the agent, prompts it with the latest user message, and returns both the AI's text response ",(0,o.kt)("em",{parentName:"p"},"and")," any booking requests the tools collected. The workflow gets everything it needs in one shot."),(0,o.kt)("h2",{id:"the-workflow-where-it-all-comes-together"},"The Workflow: Where It All Comes Together"),(0,o.kt)("p",null,"Here's the complete workflow. (You can also view it on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/durable-workflow/sample-app/blob/main/app/Workflows/Ai/AiWorkflow.php"},"GitHub"),".) Read it top to bottom. It's the entire orchestration layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"class AiWorkflow extends Workflow\n{\n    private const INACTIVITY_TIMEOUT = '2 minutes';\n\n    private const MAX_MESSAGES = 20;\n\n    #[SignalMethod]\n    public function send(string $message): void\n    {\n        $this->inbox->receive($message);\n    }\n\n    #[UpdateMethod]\n    public function receive()\n    {\n        return $this->outbox->nextUnsent();\n    }\n\n    public function execute($injectFailure = null)\n    {\n        $messages = [];\n\n        try {\n            while (count($messages) < self::MAX_MESSAGES) {\n                $receivedMessage = yield awaitWithTimeout(\n                    self::INACTIVITY_TIMEOUT,\n                    fn () => $this->inbox->hasUnread(),\n                );\n\n                if (! $receivedMessage) {\n                    throw new Exception(\n                        'Session ended due to inactivity. Please start a new conversation.'\n                    );\n                }\n\n                $messages[] = new UserMessage($this->inbox->nextUnread());\n                $result = yield activity(TravelAgentActivity::class, $messages);\n                $data = json_decode($result, true);\n\n                foreach ($data['bookings'] as $booking) {\n                    yield from $this->handleBooking($booking, $injectFailure);\n                }\n\n                $messages[] = new AssistantMessage($data['text']);\n                $this->outbox->send($data['text']);\n            }\n\n            if (count($messages) >= self::MAX_MESSAGES) {\n                throw new Exception(\n                    'This conversation has reached its message limit. '\n                    . 'Please start a new conversation to continue.'\n                );\n            }\n\n        } catch (Throwable $th) {\n            yield from $this->compensate();\n            $this->outbox->send(\n                $th->getMessage() . ' Any previous bookings have been cancelled.'\n            );\n        }\n\n        return $messages;\n    }\n\n    private function handleBooking(array $data, ?string $injectFailure)\n    {\n        return match ($data['type']) {\n            'book_hotel' => $this->bookHotel($data, $injectFailure),\n            'book_flight' => $this->bookFlight($data, $injectFailure),\n            'book_rental_car' => $this->bookRentalCar($data, $injectFailure),\n        };\n    }\n\n    private function bookHotel(array $data, ?string $injectFailure)\n    {\n        $hotel = yield activity(\n            BookHotelActivity::class,\n            $data['hotel_name'],\n            $data['check_in_date'],\n            $data['check_out_date'],\n            (int) $data['guests'],\n            $injectFailure === 'hotel',\n        );\n        $this->addCompensation(fn () => activity(CancelHotelActivity::class, $hotel));\n\n        return $hotel;\n    }\n\n    private function bookFlight(array $data, ?string $injectFailure)\n    {\n        $flight = yield activity(\n            BookFlightActivity::class,\n            $data['origin'],\n            $data['destination'],\n            $data['departure_date'],\n            $data['return_date'] ?? null,\n            $injectFailure === 'flight',\n        );\n        $this->addCompensation(fn () => activity(CancelFlightActivity::class, $flight));\n\n        return $flight;\n    }\n\n    private function bookRentalCar(array $data, ?string $injectFailure)\n    {\n        $rentalCar = yield activity(\n            BookRentalCarActivity::class,\n            $data['pickup_location'],\n            $data['pickup_date'],\n            $data['return_date'],\n            $injectFailure === 'car',\n        );\n        $this->addCompensation(fn () => activity(CancelRentalCarActivity::class, $rentalCar));\n\n        return $rentalCar;\n    }\n}\n")),(0,o.kt)("p",null,"There's a lot here. Let's break it down."),(0,o.kt)("h3",{id:"the-inbox--outbox-pattern"},"The Inbox / Outbox Pattern"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"#[SignalMethod]\npublic function send(string $message): void\n{\n    $this->inbox->receive($message);\n}\n\n#[UpdateMethod]\npublic function receive()\n{\n    return $this->outbox->nextUnsent();\n}\n")),(0,o.kt)("p",null,"The workflow has two communication channels. The ",(0,o.kt)("strong",{parentName:"p"},"inbox")," receives user messages via ",(0,o.kt)("inlineCode",{parentName:"p"},"SignalMethod"),", fire-and-forget signals that get appended to a durable queue. The ",(0,o.kt)("strong",{parentName:"p"},"outbox")," holds agent responses, retrieved via ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateMethod"),", synchronous queries that replay the workflow and return the next unsent message."),(0,o.kt)("p",null,"This is durable messaging. If the server crashes between receiving a user message and processing it, the message is still in the inbox when the workflow resumes. If the agent produces a response but the client disconnects before reading it, it's still in the outbox on the next poll."),(0,o.kt)("h3",{id:"timeout-as-business-logic"},"Timeout as Business Logic"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"$receivedMessage = yield awaitWithTimeout(\n    self::INACTIVITY_TIMEOUT,\n    fn () => $this->inbox->hasUnread(),\n);\n\nif (! $receivedMessage) {\n    throw new Exception('Session ended due to inactivity. Please start a new conversation.');\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"awaitWithTimeout")," pauses the workflow for up to 2 minutes, waiting for the condition to become true. If the user sends a message, execution continues immediately. If they don't, it returns ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," and we throw an exception to end the conversation."),(0,o.kt)("p",null,"No cron job. No scheduled command. No database polling. The timeout is expressed ",(0,o.kt)("em",{parentName:"p"},"as part of the business logic"),", right where it belongs. The framework handles the timer durably. If the server restarts during the 2-minute window, the timer picks up where it left off."),(0,o.kt)("h3",{id:"the-conversation-loop"},"The Conversation Loop"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"while (count($messages) < self::MAX_MESSAGES) {\n    // Wait for user input (with timeout)\n    // Read the message\n    // Run the AI agent\n    // Process any bookings\n    // Send the response\n}\n")),(0,o.kt)("p",null,"This reads like pseudocode, but it's the real implementation. Each iteration:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Waits")," for a user message (durably, with timeout)"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Reads")," the next unread message from the inbox"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Runs")," the AI agent as a durable activity, passing the full conversation history"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Processes")," any booking requests the agent's tools collected"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Sends")," the agent's text response to the outbox")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"$messages")," array accumulates ",(0,o.kt)("inlineCode",{parentName:"p"},"UserMessage")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AssistantMessage")," objects as the conversation progresses. It's passed to the agent on every turn so it has full context. And because everything is inside a durable workflow, if the queue worker crashes after step 3 but before step 5, it replays from where it left off."),(0,o.kt)("h3",{id:"the-saga-pattern-star-of-the-show"},"The Saga Pattern: Star of the Show"),(0,o.kt)("p",null,"This is where it gets interesting."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"private function bookHotel(array $data, ?string $injectFailure)\n{\n    $hotel = yield activity(\n        BookHotelActivity::class,\n        $data['hotel_name'],\n        $data['check_in_date'],\n        $data['check_out_date'],\n        (int) $data['guests'],\n        $injectFailure === 'hotel',\n    );\n    $this->addCompensation(fn () => activity(CancelHotelActivity::class, $hotel));\n\n    return $hotel;\n}\n")),(0,o.kt)("p",null,"After each successful booking, we register a compensation action. ",(0,o.kt)("inlineCode",{parentName:"p"},"addCompensation")," takes a callable that knows ",(0,o.kt)("em",{parentName:"p"},"exactly")," how to undo what was just done, including the confirmation number, dates, and all the details returned by the booking activity."),(0,o.kt)("p",null,"The framework remembers the hotel confirmation."),(0,o.kt)("p",null,"If any subsequent step throws an exception, the ",(0,o.kt)("inlineCode",{parentName:"p"},"catch")," block runs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"catch (Throwable $th) {\n    yield from $this->compensate();\n    $this->outbox->send(\n        $th->getMessage() . ' Any previous bookings have been cancelled.'\n    );\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"$this->compensate()")," executes all registered compensation actions ",(0,o.kt)("strong",{parentName:"p"},"in reverse order"),". If you booked a hotel, then a flight, then a rental car, and the rental car fails, the flight gets cancelled first, then the hotel. To cancel them in parallel instead, we can set ",(0,o.kt)("inlineCode",{parentName:"p"},"$this->setParallelCompensation(true)"),"."),(0,o.kt)("p",null,"And notice: the inactivity timeout and message limit are thrown as exceptions too. If a user walks away mid-booking, the ",(0,o.kt)("inlineCode",{parentName:"p"},"catch")," block fires, compensation runs, and all their reservations get cleaned up. Every exit path goes through the same cleanup logic."),(0,o.kt)("h2",{id:"what-just-happened"},"What Just Happened"),(0,o.kt)("p",null,"Let's trace through the actual execution when a user books a hotel and a flight, but the flight fails:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"You: book Grand Hotel in Paris for 2 guests, check-in 2026-03-01,\n     check-out 2026-03-03. Also book a flight NYC to Paris departing\n     2026-03-01 returning 2026-03-03.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"1. Hotel books successfully \u2705")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"BookHotelActivity ........... RUNNING\nBooking hotel: Grand Hotel, Paris, 2026-03-01 to 2026-03-03,\n2 guest(s). Confirmation #902928\nBookHotelActivity .......... 4.35ms DONE\n")),(0,o.kt)("p",null,"The workflow now has a compensation registered:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},'fn () => activity(CancelHotelActivity::class, "Hotel booked: Grand Hotel... Confirmation #902928")\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"2. Flight fails \u274c")," (injected failure for demo purposes)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"BookFlightActivity .......... RUNNING\nBookFlightActivity ......... 8.37ms FAIL\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NonRetryableException")," propagates up to the ",(0,o.kt)("inlineCode",{parentName:"p"},"catch")," block."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"3. Saga compensation kicks in automatically \ud83d\udd04")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"CancelHotelActivity ......... RUNNING\nCancelling hotel Hotel booked: Grand Hotel, Paris, check-in 2026-03-01,\ncheck-out 2026-03-03, 2 guest(s). Confirmation #902928...\nCancelHotelActivity ....... 3.74ms DONE\n")),(0,o.kt)("p",null,"The framework ran the compensation with the ",(0,o.kt)("em",{parentName:"p"},"exact")," confirmation details from the original booking."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"4. User gets clean feedback \ud83d\udcac")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Agent: Flight booking failed: New York to Paris.\n       Any previous bookings have been cancelled.\n")),(0,o.kt)("p",null,"The error message is conversational, not a stack trace. The user knows what happened and what was cleaned up."),(0,o.kt)("h2",{id:"without-sagas"},"Without Sagas?"),(0,o.kt)("p",null,"Consider what you'd need without this pattern:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Orphaned hotel booking.")," Confirmation #902928 is still reserved, costing real money."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Manual cleanup.")," Someone has to find and cancel it."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Database queries")," to figure out which bookings belong to this conversation."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Race conditions.")," What if the user retries while you're cleaning up?"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Scattered compensation logic.")," Cancel handlers spread across event listeners, with no guarantee they all run."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Angry customers and support tickets.")," The inevitable result.")),(0,o.kt)("p",null,"With sagas, it's one line per booking:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"$this->addCompensation(fn () => activity(CancelHotelActivity::class, $hotel));\n")),(0,o.kt)("p",null,"The framework handles the rest."),(0,o.kt)("h2",{id:"key-innovations"},"Key Innovations"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Timeouts as business logic.")," ",(0,o.kt)("inlineCode",{parentName:"p"},"awaitWithTimeout('2 minutes', ...)")," expresses a timeout right in the workflow code, not as infrastructure configuration. If the user goes idle, the conversation ends gracefully with compensation."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Conversational error messages."),' Every failure path (booking errors, timeouts, message limits) flows through the outbox as a normal message. The user never sees a stack trace or a "Something went wrong" page.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Automatic cleanup on every exit.")," The ",(0,o.kt)("inlineCode",{parentName:"p"},"try/catch")," wrapping the entire conversation loop means ",(0,o.kt)("em",{parentName:"p"},"any")," exception triggers compensation. The conversation can't end with orphaned bookings, no matter how it ends."),(0,o.kt)("h2",{id:"the-traditional-approach"},"The Traditional Approach"),(0,o.kt)("p",null,"Let's estimate what this would take with traditional Laravel patterns:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Concern"),(0,o.kt)("th",{parentName:"tr",align:null},"Traditional"),(0,o.kt)("th",{parentName:"tr",align:null},"Durable Workflow"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"State tracking"),(0,o.kt)("td",{parentName:"tr",align:null},"Database table + state machine"),(0,o.kt)("td",{parentName:"tr",align:null},"Implicit in workflow position")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Timeout handling"),(0,o.kt)("td",{parentName:"tr",align:null},"Cron job + stale detection"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"awaitWithTimeout()"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Failure compensation"),(0,o.kt)("td",{parentName:"tr",align:null},"Event listeners + manual queries"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"addCompensation()")," + ",(0,o.kt)("inlineCode",{parentName:"td"},"compensate()"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Crash recovery"),(0,o.kt)("td",{parentName:"tr",align:null},"Custom retry logic + idempotency"),(0,o.kt)("td",{parentName:"tr",align:null},"Automatic replay")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Race conditions"),(0,o.kt)("td",{parentName:"tr",align:null},"Locks + transactions"),(0,o.kt)("td",{parentName:"tr",align:null},"Single-threaded workflow execution")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Cleanup"),(0,o.kt)("td",{parentName:"tr",align:null},"Scheduled commands + orphan detection"),(0,o.kt)("td",{parentName:"tr",align:null},"Catch block")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Total")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"~500 lines across 10+ files")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"~100 lines in 1 file"))))),(0,o.kt)("p",null,"The traditional approach isn't just more code, it's more ",(0,o.kt)("em",{parentName:"p"},"categories")," of code. You're writing infrastructure: state machines, cleanup jobs, event wiring, retry logic. With a durable workflow, you're writing business logic: wait for a message, call the agent, book the hotel, compensate on failure."),(0,o.kt)("h2",{id:"observability"},"Observability"),(0,o.kt)("p",null,"Every message, every activity, every retry, every timeout, every exception, every compensation step, all of it is visible in real time in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/durable-workflow/waterline"},"Waterline"),"."),(0,o.kt)("p",null,"You can literally scroll through the workflow and see:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Each user message arriving via a signal"),(0,o.kt)("li",{parentName:"ul"},"Each AI turn as a durable activity"),(0,o.kt)("li",{parentName:"ul"},"Every booking attempt with inputs and outputs"),(0,o.kt)("li",{parentName:"ul"},"The exact moment a failure occurs (and the line it occured on with a stack trace)"),(0,o.kt)("li",{parentName:"ul"},"The saga compensation steps, executed automatically in reverse order"),(0,o.kt)("li",{parentName:"ul"},"How long each step took, down to the millisecond")),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"This is a paradigm shift. Instead of building infrastructure to manage state, handle failures, and coordinate distributed operations, you write a function that describes what should happen. The framework provides durability, retry, compensation, and crash recovery."),(0,o.kt)("p",null,"The entire travel agent (AI conversation, multi-step bookings, saga compensation, inactivity timeouts, message limits, and graceful error handling) is expressed in a single workflow class. Production-grade UX with development-friendly code."),(0,o.kt)("p",null,"No state machine tables. No cleanup crons. No orphaned bookings. No scattered event listeners. Just a workflow that reads like the business requirements it implements."),(0,o.kt)("h3",{id:"try-it-now-in-your-browser"},"Try It Now in Your Browser"),(0,o.kt)("p",null,"We\u2019ve bundled this workflow into the official Workflow ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/durable-workflow/sample-app"},"Sample App"),"."),(0,o.kt)("p",null,"To try it:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Open the sample-app repo on GitHub"),(0,o.kt)("li",{parentName:"ol"},"Click ",(0,o.kt)("strong",{parentName:"li"},"Code")," \u2192 ",(0,o.kt)("strong",{parentName:"li"},"Codespaces")," \u2192 ",(0,o.kt)("strong",{parentName:"li"},"Create codespace on main")),(0,o.kt)("li",{parentName:"ol"},"Wait for the environment to build"),(0,o.kt)("li",{parentName:"ol"},"Set your OPENAI_API_KEY in the .env"),(0,o.kt)("li",{parentName:"ol"},"Setup the app and start the queue worker:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan app:init\nphp artisan queue:work\n"))),(0,o.kt)("li",{parentName:"ol"},"In a second terminal:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"php artisan app:ai\n")),(0,o.kt)("p",null,"Note: You can optionally inject a failure at one of the booking steps by running it with the ",(0,o.kt)("inlineCode",{parentName:"p"},"--inject-failure")," e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"php artisan app:ai --inject-failure flight"),". Valid options are ",(0,o.kt)("inlineCode",{parentName:"p"},"hotel"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"flight")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"car"),"."))}c.isMDXComponent=!0}}]);