"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"converting-videos-with-ffmpeg","metadata":{"permalink":"/blog/converting-videos-with-ffmpeg","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-31-converting-videos-with-ffmpeg.md","source":"@site/blog/2022-10-31-converting-videos-with-ffmpeg.md","title":"Converting Videos with FFmpeg and Laravel Workflow","description":"FFmpeg is a free, open-source software project allowing you to record, convert and stream audio and video.","date":"2022-10-31T00:00:00.000Z","formattedDate":"October 31, 2022","tags":[{"label":"video","permalink":"/blog/tags/video"},{"label":"ffmpeg","permalink":"/blog/tags/ffmpeg"},{"label":"conversion","permalink":"/blog/tags/conversion"},{"label":"transcoding","permalink":"/blog/tags/transcoding"}],"readingTime":1.67,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"converting-videos-with-ffmpeg","title":"Converting Videos with FFmpeg and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["video","ffmpeg","conversion","transcoding"]},"nextItem":{"title":"Email Verifications Using Laravel Workflow","permalink":"/blog/email-verifications"}},"content":"[FFmpeg](https://ffmpeg.org/) is a free, open-source software project allowing you to record, convert and stream audio and video.\\n\\n[Laravel Queues](https://laravel.com/docs/9.x/queues) are great for long running tasks. Converting video takes a long time! With [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow), you can harness the power of queues to convert videos in the background and easily manage the process.\\n\\nRequirements\\n============\\n\\n1.  You\u2019ll need to [install FFmpeg](https://ffmpeg.org/download.html)\\n2.  Then `composer require php-ffmpeg/php-ffmpeg` ([docs](https://github.com/PHP-FFMpeg/PHP-FFMpeg#readme))\\n3.  Finally `composer require laravel-workflow/laravel-workflow` ([docs](https://github.com/laravel-workflow/laravel-workflow#laravel-workflow-))\\n\\nWorkflow\\n========\\n\\nA workflow is an easy way to orchestrate activities. A workflow that converts a video from one format to another might have several activities, such as downloading the video from storage, the actual conversion, and then finally notifying the user that it\u2019s finished.\\n\\nFor simplicity, the workflow we are making today will only contain the most interesting activity, converting the video.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass ConvertVideoWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        yield ActivityStub::make(\\n            ConvertVideoWebmActivity::class,\\n            storage_path(\'app/oceans.mp4\'),\\n            storage_path(\'app/oceans.webm\'),\\n        );\\n    }\\n}\\n```\\n\\nWe need a video to convert. We can use this one:\\n\\n[http://vjs.zencdn.net/v/oceans.mp4](http://vjs.zencdn.net/v/oceans.mp4)\\n\\nDownload it and save it to your app storage folder.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse FFMpeg\\\\FFMpeg;\\nuse FFMpeg\\\\Format\\\\Video\\\\WebM;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertVideoWebmActivity extends Activity\\n{\\n    public $timeout = 5;\\n\\n    public function execute($input, $output)\\n    {\\n        $ffmpeg = FFMpeg::create();\\n        $video = $ffmpeg->open($input);\\n        $format = new WebM();\\n        $format->on(\'progress\', fn () => $this->heartbeat());\\n        $video->save($format, $output);\\n    }\\n}\\n```\\n\\nThe activity converts any input video into a [WebM](https://www.webmproject.org/) output video. While ffmpeg is converting the video, a progress callback is triggered which in turn heartbeats the activity.\\n\\nThis is necessary because we have set a reasonable timeout of 5 seconds but we also have no idea how long it will take to convert the video. As long as we send a heartbeat at least once every 5 seconds, the activity will not timeout.\\n\\n![heartbeat](https://miro.medium.com/max/1400/1*ccrxeOEZYQciDYEprRKWiQ.webp)\\n\\n![no heartbeat](https://miro.medium.com/max/1400/1*9ZF3LTqjf4qsVcNVX5LK0A.webp)\\n\\nWithout a heartbeat, the worker will be killed after the timeout of 5 seconds is reached.\\n\\nTo actually run the workflow you just need to call:\\n\\n```php\\nWorkflowStub::make(ConvertVideoWorkflow::class)->start();\\n```\\n\\nAnd that\u2019s it!"},{"id":"email-verifications","metadata":{"permalink":"/blog/email-verifications","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-29-email-verifications.md","source":"@site/blog/2022-10-29-email-verifications.md","title":"Email Verifications Using Laravel Workflow","description":"A typical registration process goes as follows:","date":"2022-10-29T00:00:00.000Z","formattedDate":"October 29, 2022","tags":[{"label":"emails","permalink":"/blog/tags/emails"},{"label":"verification","permalink":"/blog/tags/verification"},{"label":"signed-urls","permalink":"/blog/tags/signed-urls"}],"readingTime":4.42,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"email-verifications","title":"Email Verifications Using Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["emails","verification","signed-urls"]},"prevItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"A typical registration process goes as follows:\\n\\n1.  User fills out registration form and submits it\\n2.  Laravel creates user in database with null `email_verified_at`\\n3.  Laravel sends email with a code, or a link back to our website\\n4.  User enters code, or clicks link\\n5.  Laravel sets `email_verified_at` to the current time\\n\\nWhat\u2019s wrong with this? Nothing. But like all things, as soon as real world complexity creeps in, this pattern could become painful. What if you wanted to send an email after the code or link expires? And do you really need a user in your database if they never verify their email address?\\n\\nLet\u2019s take this trivial example and replace it with a workflow. This is based on the [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library.\\n\\nGet Started\\n===========\\n\\nCreate a standard Laravel application and create the following files. First, the API routes.\\n\\n```php\\nuse App\\\\Workflows\\\\VerifyEmail\\\\VerifyEmailWorkflow;\\nuse Illuminate\\\\Support\\\\Facades\\\\Hash;\\nuse Illuminate\\\\Support\\\\Facades\\\\Route;\\nuse Workflow\\\\WorkflowStub;\\n\\nRoute::get(\'/register\', function () {\\n    $workflow = WorkflowStub::make(VerifyEmailWorkflow::class);\\n\\n    $workflow->start(\\n        \'test+1@example.com\',\\n        Hash::make(\'password\'),\\n    );\\n\\n    return response()->json([\\n        \'workflow_id\' => $workflow->id(),\\n    ]);\\n});\\n\\nRoute::get(\'/verify-email\', function () {\\n    $workflow = WorkflowStub::load(request(\'workflow_id\'));\\n\\n    $workflow->verify();\\n\\n    return response()->json(\'ok\');\\n})->name(\'verify-email\');\\n```\\n\\nThe `register` route creates a new `VerifyEmailWorkflow` , passes in the email and password, and then starts the workflow. Notice that we hash the password before giving it to the workflow. This prevents the plain text from being stored in the workflow logs.\\n\\nThe `verify-email` route receives a workflow id, loads it and then calls the `verify()` signal method.\\n\\nNow let\u2019s take a look at the actual workflow.\\n\\n```php\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\SignalMethod;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass VerifyEmailWorkflow extends Workflow\\n{\\n    private bool $verified = false;\\n\\n    #[SignalMethod]\\n    public function verify()\\n    {\\n        $this->verified = true;\\n    }\\n\\n    public function execute($email = \'\', $password = \'\')\\n    {\\n        yield ActivityStub::make(SendEmailVerificationEmailActivity::class, $email);\\n\\n        yield WorkflowStub::await(fn () => $this->verified);\\n\\n        yield ActivityStub::make(VerifyEmailActivity::class, $email, $password);\\n    }\\n}\\n```\\n\\nTake notice of the `yield` keywords. Because PHP (and most other languages) cannot save their execution state, coroutines rather than normal functions are used inside of workflows (but not activities). A coroutine will be called multiple times in order to execute to completion.\\n\\n![graph](https://miro.medium.com/max/1400/1*6eE2Gll61IbAAU85Md75OQ.webp)\\n\\nEven though this workflow will execute to completion effectively once, it will still be partially executed four different times. The results of activities are cached so that only failed activities will be called again. Successful activities get skipped.\\n\\nBut notice that any code we write between these calls will be called multiple times. That\u2019s why your code needs to be **deterministic** inside of workflow methods! If your code has four executions, each at different times, they must still all behave the same. There are no such limitations within activity methods.\\n\\nStep By Step\\n============\\n\\nThe first time the workflow executes, it will reach the call to `SendEmailVerificationEmailActivity` , start that activity, and then exit. Workflows suspend execution while an activity is running. After the `SendEmailVerificationEmailActivity` finishes, it will resume execution of the workflow. This brings us to\u2026\\n\\nThe second time the workflow is executed, it will reach the call to `SendEmailVerificationEmailActivity` and skip it because it will already have the result of that activity. Then it will reach the call to `WorkflowStub::await()` which allows the workflow to wait for an external signal. In this case, it will come from the user clicking on the verification link they receive in their email. Once the workflow is signaled then it will execute for\u2026\\n\\nThe third time, both the calls to `SendEmailVerificationEmailActivity` and `WorkflowStub::await()` are skipped. This means that the `VerifyEmailActivity` will be started. After the final activity has executed we still have\u2026\\n\\nThe final time the workflow is called, there is nothing left to do so the workflow completes.\\n\\nNow let\u2019s take a look at the activities.\\n\\nThe first activity just sends the user an email.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Mail\\\\VerifyEmail;\\nuse Illuminate\\\\Support\\\\Facades\\\\Mail;\\nuse Workflow\\\\Activity;\\n\\nclass SendEmailVerificationEmailActivity extends Activity\\n{\\n    public function execute($email)\\n    {\\n        Mail::to($email)->send(new VerifyEmail($this->workflowId()));\\n    }\\n}\\n```\\n\\nThe email contains a temporary signed URL that includes the workflow ID.\\n\\n```php\\nnamespace App\\\\Mail;\\n\\nuse Illuminate\\\\Bus\\\\Queueable;\\nuse Illuminate\\\\Mail\\\\Mailable;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Content;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Envelope;\\nuse Illuminate\\\\Queue\\\\SerializesModels;\\nuse Illuminate\\\\Support\\\\Facades\\\\URL;\\n\\nclass VerifyEmail extends Mailable\\n{\\n    use Queueable, SerializesModels;\\n\\n    private $workflowId;\\n\\n    public function __construct($workflowId)\\n    {\\n        $this->workflowId = $workflowId;\\n    }\\n\\n    public function envelope()\\n    {\\n        return new Envelope(\\n            subject: \'Verify Email\',\\n        );\\n    }\\n\\n    public function content()\\n    {\\n        return new Content(\\n            view: \'emails.verify-email\',\\n            with: [\\n                \'url\' => URL::temporarySignedRoute(\\n                    \'verify-email\',\\n                    now()->addMinutes(30),\\n                    [\'workflow_id\' => $this->workflowId],\\n                ),\\n            ],\\n        );\\n    }\\n\\n    public function attachments()\\n    {\\n        return [];\\n    }\\n}\\n```\\n\\nThe user gets the URL in a clickable link.\\n\\n```\\n<a href=\\"{{ $url }}\\">verification link</a>\\n```\\n\\nThis link takes the user to the `verify-email` route from our API routes, which will then start the final activity.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Models\\\\User;\\nuse Workflow\\\\Activity;\\n\\nclass VerifyEmailActivity extends Activity\\n{\\n    public function execute($email, $password)\\n    {\\n        $user = new User();\\n        $user->name = \'\';\\n        $user->email = $email;\\n        $user->email_verified_at = now();\\n        $user->password = $password;\\n        $user->save();\\n    }\\n}\\n```\\n\\nWe have created the user and verified their email address at the same time. Neat!\\n\\nWrapping Up\\n===========\\n\\nIf we take a look at the output of `php artisan queue:work` we can better see how the workflow and individual activities are interleaved.\\n\\n![queue worker](https://miro.medium.com/max/1400/1*q6-r41SN-uWfzp6p7Z4r8g.webp)\\n\\nWe can see the four different executions of the workflow, the individual activities and the signal we sent.\\n\\nThe [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library is heavily inspired by [Temporal](https://temporal.io/) but powered by [Laravel Queues](https://laravel.com/docs/9.x/queues).\\n\\nThanks for reading!"}]}')}}]);