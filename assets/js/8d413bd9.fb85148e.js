"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[8507],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2043:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={slug:"combining-laravel-workflow-and-state-machines",title:"Combining Workflow and State Machines",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png"},tags:["side-effects","random","determinism"]},r=void 0,l={permalink:"/blog/combining-laravel-workflow-and-state-machines",editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md",source:"@site/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md",title:"Combining Workflow and State Machines",description:"When it comes to building web applications, managing complex processes and activities can be a daunting task. Workflow (the Laravel-native durable workflow package) simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Workflow along with a state machine and walk through an example of integrating Workflow with Finite, a simple state machine library.",date:"2023-04-25T00:00:00.000Z",formattedDate:"April 25, 2023",tags:[{label:"side-effects",permalink:"/blog/tags/side-effects"},{label:"random",permalink:"/blog/tags/random"},{label:"determinism",permalink:"/blog/tags/determinism"}],readingTime:3.62,hasTruncateMarker:!1,authors:[{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"}],frontMatter:{slug:"combining-laravel-workflow-and-state-machines",title:"Combining Workflow and State Machines",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"},tags:["side-effects","random","determinism"]},prevItem:{title:"Saga Pattern and Workflow",permalink:"/blog/saga-pattern-and-laravel-workflow"},nextItem:{title:"Introducing Child Workflows in Workflow",permalink:"/blog/introducing-child-workflows-in-laravel-workflow"}},s={authorsImageUrls:[void 0]},c=[],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When it comes to building web applications, managing complex processes and activities can be a daunting task. Workflow (the Laravel-native durable workflow package) simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Workflow along with a state machine and walk through an example of integrating Workflow with Finite, a simple state machine library."),(0,i.kt)("h1",{id:"benefits-of-combining-workflow-and-state-machines"},"Benefits of Combining Workflow and State Machines"),(0,i.kt)("p",null,"Using the Workflow package and a state machine together provides several advantages:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Flexibility and modularity: Workflow allows developers to break down complex processes into smaller, modular units that are easy to maintain and update."),(0,i.kt)("li",{parentName:"ol"},"Explicit control over transitions: State machines provide a clear visualization of workflow states, activities, and transitions, making it easier to understand and maintain."),(0,i.kt)("li",{parentName:"ol"},"Robust error handling and retries: Workflow offers built-in support for handling errors and retries, ensuring that workflows are executed reliably and consistently."),(0,i.kt)("li",{parentName:"ol"},"Scalability: Workflow supports queuing and parallel execution, allowing workflows to be executed asynchronously on worker servers."),(0,i.kt)("li",{parentName:"ol"},"Integration with Laravel\u2019s queue and event systems: This allows for seamless integration with other Laravel features and packages.")),(0,i.kt)("h1",{id:"installation-guide"},"Installation Guide"),(0,i.kt)("p",null,"To get started with Workflow and Finite, you will need to install them in your Laravel project:"),(0,i.kt)("p",null,"For Workflow, run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"composer require laravel-workflow/laravel-workflow\n")),(0,i.kt)("p",null,"For ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/yohang/Finite"},"Finite"),", run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"composer require yohang/finite\n")),(0,i.kt)("h1",{id:"loan-application-workflow-example"},"Loan Application Workflow Example"),(0,i.kt)("p",null,"The following code demonstrates how to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow")," using Workflow and Finite:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Finite\\StatefulInterface;  \nuse Finite\\StateMachine\\StateMachine;  \nuse Finite\\State\\State;  \nuse Finite\\State\\StateInterface;  \nuse function Workflow\\await;\nuse Workflow\\Models\\StoredWorkflow;  \nuse Workflow\\SignalMethod;  \nuse Workflow\\Workflow;  \n  \nclass LoanApplicationWorkflow extends Workflow implements StatefulInterface  \n{  \n    private $state;  \n    private $stateMachine;  \n  \n    public function setFiniteState($state)  \n    {  \n        $this->state = $state;  \n    }  \n  \n    public function getFiniteState()  \n    {  \n        return $this->state;  \n    }  \n  \n    #[SignalMethod]  \n    public function submit()  \n    {  \n        $this->stateMachine->apply('submit');  \n    }  \n  \n    #[SignalMethod]  \n    public function approve()  \n    {  \n        $this->stateMachine->apply('approve');  \n    }  \n  \n    #[SignalMethod]  \n    public function deny()  \n    {  \n        $this->stateMachine->apply('deny');  \n    }  \n  \n    public function isSubmitted()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'submitted';  \n    }  \n  \n    public function isApproved()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'approved';  \n    }  \n  \n    public function isDenied()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'denied';  \n    }  \n  \n    public function __construct(  \n        public StoredWorkflow $storedWorkflow,  \n        ...$arguments  \n    ) {  \n        parent::__construct($storedWorkflow, $arguments);  \n  \n        $this->stateMachine = new StateMachine();  \n  \n        $this->stateMachine->addState(new State('created', StateInterface::TYPE\\_INITIAL));  \n        $this->stateMachine->addState('submitted');  \n        $this->stateMachine->addState(new State('approved', StateInterface::TYPE\\_FINAL));  \n        $this->stateMachine->addState(new State('denied', StateInterface::TYPE\\_FINAL));  \n  \n        $this->stateMachine->addTransition('submit', 'created', 'submitted');  \n        $this->stateMachine->addTransition('approve', 'submitted', 'approved');  \n        $this->stateMachine->addTransition('deny', 'submitted', 'denied');  \n  \n        $this->stateMachine->setObject($this);  \n        $this->stateMachine->initialize();  \n    }  \n  \n    public function execute()  \n    {  \n        // loan created  \n  \n        yield await(fn () => $this->isSubmitted());  \n  \n        // loan submitted  \n  \n        yield await(fn () => $this->isApproved() || $this->isDenied());  \n  \n        // loan approved/denied  \n  \n        return $this->stateMachine->getCurrentState()->getName();  \n    }  \n}\n")),(0,i.kt)("p",null,"In this example, we define a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow")," class that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"Workflow")," and implements ",(0,i.kt)("inlineCode",{parentName:"p"},"StatefulInterface"),". The workflow has four states: created, submitted, approved or denied. The workflow transitions between these states by externally calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"submit()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"approve()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"deny()")," signal methods."),(0,i.kt)("p",null,"To use the ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow"),", you can create a new instance of it, start the workflow, submit the loan application, approve it, and get the output as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'// create workflow  \n$workflow = WorkflowStub::make(LoanApplicationWorkflow::class);  \n  \n// start workflow  \n$workflow->start();  \n  \nsleep(1);  \n  \n// submit signal  \n$workflow->submit();  \n  \nsleep(1);  \n  \n// approve signal  \n$workflow->approve();  \n  \nsleep(1);  \n  \n$workflow->output();  \n// "approved"\n')),(0,i.kt)("p",null,"This is the view from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/laravel-workflow/waterline"},"Waterline"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1400/1*m6cOftX9kjBjr6CJGpyQPA.webp",alt:"timeline"})),(0,i.kt)("h1",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Although Workflow offers a way to define and manage workflows and activities, some developers might still prefer to use a state machine to have more explicit control over the transitions between states or activities."),(0,i.kt)("p",null,"A state machine can provide a more structured and visual representation of the workflow, making it easier to understand and maintain. In such cases, a state machine library can be integrated with Workflow. This allows developers to define their workflow states, activities, and transitions using the state machine library while still leveraging Workflow\u2019s features, such as queuing, parallel execution, error handling, retries, and integration with Laravel\u2019s queue and event systems."),(0,i.kt)("p",null,"The Laravel developer community has created several state machine packages that can be integrated with Workflow, such as the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/yohang/Finite"},"https://github.com/yohang/Finite")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spatie/laravel-model-states"},"https://github.com/spatie/laravel-model-states")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sebdesign/laravel-state-machine"},"https://github.com/sebdesign/laravel-state-machine")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/symfony/workflow"},"https://github.com/symfony/workflow"))),(0,i.kt)("p",null,"By integrating a state machine library with Workflow, developers can get the best of both worlds: the flexibility and modularity of Workflow and the explicit control and visualization of a state machine. This can help to create more maintainable, robust, and scalable workflows for complex business processes."))}u.isMDXComponent=!0}}]);