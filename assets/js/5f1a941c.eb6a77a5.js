"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[5409],{3905:(e,n,l)=>{l.d(n,{Zo:()=>c,kt:()=>k});var t=l(7294);function o(e,n,l){return n in e?Object.defineProperty(e,n,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[n]=l,e}function r(e,n){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),l.push.apply(l,t)}return l}function i(e){for(var n=1;n<arguments.length;n++){var l=null!=arguments[n]?arguments[n]:{};n%2?r(Object(l),!0).forEach((function(n){o(e,n,l[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):r(Object(l)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(l,n))}))}return e}function a(e,n){if(null==e)return{};var l,t,o=function(e,n){if(null==e)return{};var l,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||(o[l]=e[l]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(o[l]=e[l])}return o}var s=t.createContext({}),d=function(e){var n=t.useContext(s),l=n;return e&&(l="function"==typeof e?e(n):i(i({},n),e)),l},c=function(e){var n=d(e.components);return t.createElement(s.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var l=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),u=d(l),f=o,k=u["".concat(s,".").concat(f)]||u[f]||h[f]||r;return l?t.createElement(k,i(i({ref:n},c),{},{components:l})):t.createElement(k,i({ref:n},c))}));function k(e,n){var l=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=l.length,i=new Array(r);i[0]=f;var a={};for(var s in n)hasOwnProperty.call(n,s)&&(a[s]=n[s]);a.originalType=e,a[u]="string"==typeof e?e:o,i[1]=a;for(var d=2;d<r;d++)i[d]=l[d];return t.createElement.apply(null,i)}return t.createElement.apply(null,l)}f.displayName="MDXCreateElement"},6985:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var t=l(7462),o=(l(7294),l(3905));const r={sidebar_position:7},i="Child Workflows",a={unversionedId:"features/child-workflows",id:"features/child-workflows",title:"Child Workflows",description:"It's often necessary to break down complex processes into smaller, more manageable units. Child workflows provide a way to encapsulate a sub-process within a parent workflow. This allows you to create hierarchical and modular structures for your workflows, making them more organized and maintainable.",source:"@site/docs/features/child-workflows.md",sourceDirName:"features",slug:"/features/child-workflows",permalink:"/docs/features/child-workflows",draft:!1,editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/docs/features/child-workflows.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Side Effects",permalink:"/docs/features/side-effects"},next:{title:"Concurrency",permalink:"/docs/features/concurrency"}},s={},d=[{value:"Signaling Child Workflows",id:"signaling-child-workflows",level:2},{value:"Getting a Child Handle",id:"getting-a-child-handle",level:3},{value:"Multiple Children",id:"multiple-children",level:3},{value:"Forwarding Signals to Children",id:"forwarding-signals-to-children",level:3},{value:"Getting Child Workflow IDs",id:"getting-child-workflow-ids",level:3},{value:"Async Activities",id:"async-activities",level:2}],c={toc:d};function u(e){let{components:n,...l}=e;return(0,o.kt)("wrapper",(0,t.Z)({},c,l,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"child-workflows"},"Child Workflows"),(0,o.kt)("p",null,"It's often necessary to break down complex processes into smaller, more manageable units. Child workflows provide a way to encapsulate a sub-process within a parent workflow. This allows you to create hierarchical and modular structures for your workflows, making them more organized and maintainable."),(0,o.kt)("p",null,"A child workflow is just like any other workflow. The only difference is how it's invoked within the parent workflow, using ",(0,o.kt)("inlineCode",{parentName:"p"},"ChildWorkflowStub::make()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\nuse Workflow\\Workflow;\n\nclass ParentWorkflow extends Workflow\n{\n    public function execute()\n    {\n        $result = yield ChildWorkflowStub::make(ChildWorkflow::class);\n    }\n}\n")),(0,o.kt)("h2",{id:"signaling-child-workflows"},"Signaling Child Workflows"),(0,o.kt)("p",null,"Parent workflows can signal their child workflows to coordinate behavior or pass data. To signal a child safely without corrupting the parent's execution context, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"child()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"children()")," methods."),(0,o.kt)("h3",{id:"getting-a-child-handle"},"Getting a Child Handle"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"child()")," method returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"ChildWorkflowHandle")," for the most recently created child workflow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\nuse Workflow\\Workflow;\n\nclass ParentWorkflow extends Workflow\n{\n    public function execute()\n    {\n        $child = ChildWorkflowStub::make(ChildWorkflow::class);\n\n        $childHandle = $this->child();\n\n        $childHandle->process('approved');\n\n        $result = yield $child;\n\n        return $result;\n    }\n}\n")),(0,o.kt)("h3",{id:"multiple-children"},"Multiple Children"),(0,o.kt)("p",null,"Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"children()")," method to get handles for all child workflows created by the parent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\nuse Workflow\\Workflow;\n\nclass ParentWorkflow extends Workflow\n{\n    public function execute()\n    {\n        $child1 = ChildWorkflowStub::make(ChildWorkflow::class, 'first');\n        $child2 = ChildWorkflowStub::make(ChildWorkflow::class, 'second');\n        $child3 = ChildWorkflowStub::make(ChildWorkflow::class, 'third');\n\n        $childHandles = $this->children();\n\n        foreach ($childHandles as $childHandle) {\n            $childHandle->process('approved');\n        }\n\n        $results = yield ChildWorkflowStub::all([$child1, $child2, $child3]);\n\n        return $results;\n    }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"children()")," method returns children in reverse chronological order (most recently created first)."),(0,o.kt)("h3",{id:"forwarding-signals-to-children"},"Forwarding Signals to Children"),(0,o.kt)("p",null,"You can forward external signals to child workflows by combining signal methods with child handles:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\nuse Workflow\\SignalMethod;\nuse Workflow\\Workflow;\nuse Workflow\\WorkflowStub;\n\nclass ParentWorkflow extends Workflow\n{\n    private bool $processed = false;\n    private ?string $status = null;\n\n    #[SignalMethod]\n    public function process(string $status)\n    {\n        $this->processed = true;\n        $this->status = $status;\n    }\n\n    public function execute()\n    {\n        $child = ChildWorkflowStub::make(ChildWorkflow::class);\n\n        $childHandle = $this->child();\n\n        yield WorkflowStub::await(fn () => $this->processed);\n\n        $childHandle->process($this->status);\n\n        $result = yield $child;\n\n        return $result;\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Important:")," Always call ",(0,o.kt)("inlineCode",{parentName:"p"},"$this->child()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"$this->children()")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute()")," method. Never call these methods in signal methods or query methods, as this violates determinism during workflow replay."),(0,o.kt)("h3",{id:"getting-child-workflow-ids"},"Getting Child Workflow IDs"),(0,o.kt)("p",null,"You can access the underlying stored workflow ID using the ",(0,o.kt)("inlineCode",{parentName:"p"},"id()")," method. This allows you to store the ID for external systems to signal the child directly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\ChildWorkflowStub;\nuse Workflow\\Workflow;\n\nclass ParentWorkflow extends Workflow\n{    \n    public function execute()\n    {\n        $child = ChildWorkflowStub::make(ChildWorkflow::class);\n        yield ActivityStub::make(StoreWorkflowIdActivity::class, $this->child()->id());\n        yield $child;\n    }\n}\n")),(0,o.kt)("p",null,"or"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ChildWorkflowStub;\nuse Workflow\\QueryMethod;\nuse Workflow\\Workflow;\n\nclass ParentWorkflow extends Workflow\n{\n    private ?int $childId = null;\n\n    #[QueryMethod]\n    public function childId(): ?int\n    {\n        return $this->childId;\n    }\n\n    public function execute()\n    {\n        $child = ChildWorkflowStub::make(ChildWorkflow::class);\n        $childHandle = $this->child();\n        yield WorkflowStub::await(fn () => !is_null($childHandle));\n        $this->childId = $childHandle->id();\n        yield $child;\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Important:")," When using query methods in the same workflow with child handles, you must first await for the child handle to be available. Query methods like ",(0,o.kt)("inlineCode",{parentName:"p"},"$workflow->childId()")," may return ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if you query the parent workflow before the child workflow has started."),(0,o.kt)("p",null,"Then you can interact with the child workflow directly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"$workflow = WorkflowStub::load($workflowId);\nif ($childId = $workflow->childId()) {\n    WorkflowStub::load($childId)->process('approved');\n}\n")),(0,o.kt)("h2",{id:"async-activities"},"Async Activities"),(0,o.kt)("p",null,"Rather than creating a child workflow, you can pass a callback to ",(0,o.kt)("inlineCode",{parentName:"p"},"ActivityStub::async()")," and it will be executed in the context of a separate workflow."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\Workflow;\n\nclass AsyncWorkflow extends Workflow\n{\n    public function execute()\n    {\n        [$result, $otherResult] = yield ActivityStub::async(function () {\n            $result = yield ActivityStub::make(Activity::class);\n            $otherResult = yield ActivityStub::make(OtherActivity::class, 'other');\n            return [$result, $otherResult];\n        });\n    }\n}\n")))}u.isMDXComponent=!0}}]);