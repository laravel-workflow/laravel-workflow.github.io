"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[8727],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>f});var o=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function n(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,i=function(e,t){if(null==e)return{};var r,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):n(n({},t),e)),r},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=i,f=h["".concat(l,".").concat(p)]||h[p]||d[p]||a;return r?o.createElement(f,n(n({ref:t},u),{},{components:r})):o.createElement(f,n({ref:t},u))}));function f(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,n=new Array(a);n[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,n[1]=s;for(var c=2;c<a;c++)n[c]=r[c];return o.createElement.apply(null,n)}return o.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5496:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=r(7462),i=(r(7294),r(3905));const a={sidebar_position:8},n="How It Works",s={unversionedId:"how-it-works",id:"how-it-works",title:"How It Works",description:"Laravel Workflow is a library that uses Laravel's queued jobs and event sourced persistence to create durable coroutines.",source:"@site/docs/how-it-works.md",sourceDirName:".",slug:"/how-it-works",permalink:"/docs/how-it-works",draft:!1,editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/docs/how-it-works.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Constraints Summary",permalink:"/docs/constraints/constraints-summary"},next:{title:"Monitoring",permalink:"/docs/monitoring"}},l={},c=[{value:"Queues",id:"queues",level:2},{value:"Event Sourcing",id:"event-sourcing",level:2},{value:"Coroutines",id:"coroutines",level:2},{value:"Activities",id:"activities",level:2},{value:"Promises",id:"promises",level:2},{value:"Example",id:"example",level:2},{value:"Sequence Diagram",id:"sequence-diagram",level:2},{value:"Summary",id:"summary",level:2}],u={toc:c};function h(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,o.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-it-works"},"How It Works"),(0,i.kt)("p",null,"Laravel Workflow is a library that uses Laravel's queued jobs and event sourced persistence to create durable coroutines."),(0,i.kt)("h2",{id:"queues"},"Queues"),(0,i.kt)("p",null,"Queued jobs are background processes that are scheduled to run at a later time. Laravel supports running queues via Amazon SQS, Redis, or even a relational database."),(0,i.kt)("h2",{id:"event-sourcing"},"Event Sourcing"),(0,i.kt)("p",null,"Event sourcing is a way to build up the current state from a sequence of saved events rather than saving the state directly. This has several benefits, such as providing a complete history of the execution events which can be used to resume a workflow if the server it is running on crashes."),(0,i.kt)("h2",{id:"coroutines"},"Coroutines"),(0,i.kt)("p",null,"Coroutines are functions that allow execution to be suspended and resumed by returning control to the calling function. In PHP, this is done using the yield keyword inside a generator. A generator is typically invoked by calling the ",(0,i.kt)("a",{parentName:"p",href:"https://www.php.net/manual/en/generator.current.php"},(0,i.kt)("inlineCode",{parentName:"a"},"Generator::current()"))," method. This will execute the generator up to the first yield and then control will be returned to the caller."),(0,i.kt)("p",null,"In Laravel Workflow, the execute() method of a workflow class is a ",(0,i.kt)("a",{parentName:"p",href:"https://www.php.net/manual/en/language.generators.syntax.php"},"generator"),". It works by yielding each activity. This allows the workflow to first check if the activity has already successfully completed. If so, the cached result is pulled from the event store and returned instead of running the activity a second time. If the activity hasn't been successfully completed before, it will queue the activity to run. The workflow is then able to suspend execution until the activity completes or fails."),(0,i.kt)("h2",{id:"activities"},"Activities"),(0,i.kt)("p",null,"By calling multiple activities, a workflow can orchestrate the results between each of the activities. The execution of the workflow and the activities it yields are interleaved, with the workflow yielding an activity, suspending execution until the activity completes, and then continuing execution from where it left off."),(0,i.kt)("p",null,"If a workflow fails, the events leading up to the failure are replayed to rebuild the current state. This allows the workflow to pick up where it left off, with the same inputs and outputs as before, ensuring determinism."),(0,i.kt)("h2",{id:"promises"},"Promises"),(0,i.kt)("p",null,"Promises are used to represent the result of an asynchronous operation, such as an activity. The yield keyword suspends execution until the promise is fulfilled or rejected. This allows the workflow to wait for an activity to complete before continuing execution."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Workflow\\ActivityStub;\nuse Workflow\\Workflow;\n\nclass MyWorkflow extends Workflow\n{\n    public function execute()\n    {\n        return [\n            yield ActivityStub::make(TestActivity::class),\n            yield ActivityStub::make(TestOtherActivity::class),\n            yield ActivityStub::all([\n                ActivityStub::make(TestParallelActivity::class),\n                ActivityStub::make(TestParallelOtherActivity::class),\n            ]),\n        ];\n    }\n}\n")),(0,i.kt)("h2",{id:"sequence-diagram"},"Sequence Diagram"),(0,i.kt)("p",null,"This sequence diagram shows how a Laravel Workflow progresses through a series of activities, both serial and parallel."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/1130888/206589649-8fc0044d-8089-45a7-a30f-e1bcbb5115cd.png",alt:"mermaid-diagram-2022-12-08-173913"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The workflow starts by calling the execute method, which saves the initial state of the workflow to the database."),(0,i.kt)("li",{parentName:"ol"},"The first activity, TestActivity, is then started by calling its execute method. Once TestActivity has completed, it returns control to the workflow and the workflow saves the updated state to the database."),(0,i.kt)("li",{parentName:"ol"},"At this point, the workflow enters the event sourcing replay loop. This is where it goes back to the database and looks at the event stream to rebuild the current state. This is necessary because the workflow may have been restarted or resumed from a previous state."),(0,i.kt)("li",{parentName:"ol"},"Once the event stream has been replayed, the workflow continues to the next activity, TestOtherActivity, and starts it by calling its execute method. Again, once TestOtherActivity has completed, it returns control to the workflow and the workflow saves the updated state to the database."),(0,i.kt)("li",{parentName:"ol"},"The workflow then enters the event sourcing replay loop again, rebuilding the current state from the event stream."),(0,i.kt)("li",{parentName:"ol"},"Next, the workflow starts two parallel activities, TestParallelActivity and TestOtherParallelActivity. Both activities are started by calling their execute methods. Once they have completed, they return control to the workflow and the workflow saves the updated state to the database."),(0,i.kt)("li",{parentName:"ol"},"Finally, the workflow enters the event sourcing replay loop one last time to rebuild the current state from the event stream. This completes the execution of the workflow.")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"The sequence diagram illustrates the workflow starting with the TestActivity and then the TestOtherActivity being executed in series. After both activities complete, the workflow replayed the events in order to rebuild the current state. This process is necessary in order to ensure that the workflow can be resumed after a crash or other interruption."),(0,i.kt)("p",null,"The need for determinism comes into play when the events are replayed. In order for the workflow to rebuild the correct state, the code for each activity must produce the same result when run multiple times with the same inputs. This means that activities should avoid using things like random numbers or dates, as these will produce different results each time they are run."),(0,i.kt)("p",null,"The need for idempotency comes into play when the workflow is resumed after a crash or other interruption. If an activity is not idempotent, it is possible for it to produce different results each time it is run. This could cause the workflow to become out of sync with the current state of the system. For example, if an activity charges a customer and is not idempotent, rerunning it after a crash could result in the customer being charged twice. To avoid this, activities should be designed to be idempotent."))}h.isMDXComponent=!0}}]);