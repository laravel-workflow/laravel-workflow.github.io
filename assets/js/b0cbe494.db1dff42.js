"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[4719],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(a),h=i,d=m["".concat(s,".").concat(h)]||m[h]||p[h]||r;return a?n.createElement(d,o(o({ref:t},u),{},{components:a})):n.createElement(d,o({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},3408:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={slug:"invalidating-cloud-images",title:"Invalidating Cloud Images in Laravel with Workflows",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png"},tags:["cache","invalidation","cloud","images"]},o=void 0,l={permalink:"/blog/invalidating-cloud-images",editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-15-invalidating-cloud-images.md",source:"@site/blog/2022-11-15-invalidating-cloud-images.md",title:"Invalidating Cloud Images in Laravel with Workflows",description:"Many services like Cloud Image offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.",date:"2022-11-15T00:00:00.000Z",formattedDate:"November 15, 2022",tags:[{label:"cache",permalink:"/blog/tags/cache"},{label:"invalidation",permalink:"/blog/tags/invalidation"},{label:"cloud",permalink:"/blog/tags/cloud"},{label:"images",permalink:"/blog/tags/images"}],readingTime:3.07,hasTruncateMarker:!1,authors:[{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"}],frontMatter:{slug:"invalidating-cloud-images",title:"Invalidating Cloud Images in Laravel with Workflows",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"},tags:["cache","invalidation","cloud","images"]},prevItem:{title:"Waterline: Elegant UI for Laravel Workflows",permalink:"/blog/waterline-ui"},nextItem:{title:"Converting Videos with FFmpeg and Laravel Workflow",permalink:"/blog/converting-videos-with-ffmpeg"}},s={authorsImageUrls:[void 0]},c=[],u={toc:c};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Many services like ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cloudimage.io/go/cloudimage-documentation-v7/en/caching-acceleration/invalidation-api"},"Cloud Image")," offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy."),(0,i.kt)("p",null,"However, it can be challenging if you want to automate this and also ensure that the image has been invalidated. This is because most invalidation APIs are asynchronous. When you request an image to be cleared from the cache, the API will return a response immediately. Then the actual process to clear the image from the cache runs in the background, sometimes taking up to 30 seconds before the image is updated. You could simply trust that the process works but it is also possible to be 100% sure with an automated workflow."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This article is part of a series on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/laravel-workflow/laravel-workflow"},"Larvel Workflow"),", a durable workflow engine that allows users to write long running persistent distributed workflows (orchestrations) in PHP powered by Laravel Queues. Inspired by Temporal and Azure Durable Functions.")),(0,i.kt)("p",null,"The workflow we need to write is as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Check the currently cached image\u2019s timestamp via HEAD call"),(0,i.kt)("li",{parentName:"ol"},"Invalidate cached image via API call"),(0,i.kt)("li",{parentName:"ol"},"Check if the image timestamp has changed"),(0,i.kt)("li",{parentName:"ol"},"If not, wait a while and check again"),(0,i.kt)("li",{parentName:"ol"},"After 3 failed checks, go back to step 2")),(0,i.kt)("p",null,"The workflow consists of two activities. The first activity gets the current timestamp of the image. This timestamp is used to determine if the image was actually cleared from the cache or not."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Workflows\\InvalidateCache;\n\nuse Illuminate\\Support\\Facades\\Http;\nuse Workflow\\Activity;\n\nclass CheckImageDateActivity extends Activity\n{\n    public function execute($url)\n    {\n        return Http::head('https://' . config('services.cloudimage.token') . '.cloudimg.io/' . $url)\n            ->header('date');\n    }\n}\n")),(0,i.kt)("p",null,"The second activity makes the actual call to Cloud Image\u2019s API to invalidate the image from the cache."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Workflows\\InvalidateCache;\n\nuse Illuminate\\Support\\Facades\\Http;\nuse Workflow\\Activity;\n\nclass InvalidateCacheActivity extends Activity\n{\n    public function execute($url)\n    {\n        Http::withHeaders([\n            'X-Client-key' => config('services.cloudimage.key'),\n            'Content-Type' => 'application/json'\n        ])->post('https://api.cloudimage.com/invalidate', [\n            'scope' => 'original',\n            'urls' => [\n                '/' . $url\n            ],\n        ]);\n    }\n}\n")),(0,i.kt)("p",null,"The workflow looks as follows and is the same process as outlined before."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"namespace App\\Workflows\\InvalidateCache;\n\nuse Workflow\\ActivityStub;\nuse Workflow\\Workflow;\nuse Workflow\\WorkflowStub;\n\nclass InvalidateCacheWorkflow extends Workflow\n{\n    public function execute($url)\n    {\n        $oldDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\n\n        while (true) {\n            yield ActivityStub::make(InvalidateCacheActivity::class, $url);\n\n            for ($i = 0; $i < 3; ++$i) { \n                yield WorkflowStub::timer(30);\n\n                $newDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\n\n                if ($oldDate !== $newDate) return;    \n            }\n        }\n    }\n}\n")),(0,i.kt)("p",null,"Line 13 uses an activity to get the current timestamp of the image we want to invalidate from the cache."),(0,i.kt)("p",null,"Line 15 starts a loop that only exits when the image timestamp has changed."),(0,i.kt)("p",null,"Line 16 uses an activity to invalidate the image from the cache."),(0,i.kt)("p",null,"Line 18 starts a loop that tries a maximum of three times to first sleep and then check if the image timestamp has change, after three times the loop restarts at line 15."),(0,i.kt)("p",null,"Line 19 sleeps the workflow for 30 seconds. This gives Cloud Image time to clear the image from their cache before checking the timestamp again."),(0,i.kt)("p",null,"Lines 21\u201323 reuse the activity from earlier to get the current timestamp of the cached image and compare it to the one saved on line 13. If the timestamps don\u2019t match then the image has successfully been cleared from the cache and we can exit the workflow. Otherwise, after three attempts, we start the process over again."),(0,i.kt)("p",null,"This is how the workflow execution looks in the queue assuming no retries are needed."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1400/1*7psZLD9mKGJnzEw508oIAw.webp",alt:"workflow execution"})),(0,i.kt)("p",null,"The added benefit is that your image is now cached again and will be fast for the next user! Thanks for reading!"))}m.isMDXComponent=!0}}]);