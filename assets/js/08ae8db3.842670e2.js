"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[2064],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(a),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},820:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={slug:"combining-laravel-workflow-and-state-machines",title:"Combining Laravel Workflow and State Machines",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png"},tags:["side-effects","random","determinism"]},o=void 0,l={permalink:"/blog/combining-laravel-workflow-and-state-machines",editUrl:"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md",source:"@site/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md",title:"Combining Laravel Workflow and State Machines",description:"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library.",date:"2023-04-25T00:00:00.000Z",formattedDate:"April 25, 2023",tags:[{label:"side-effects",permalink:"/blog/tags/side-effects"},{label:"random",permalink:"/blog/tags/random"},{label:"determinism",permalink:"/blog/tags/determinism"}],readingTime:3.665,hasTruncateMarker:!1,authors:[{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"}],frontMatter:{slug:"combining-laravel-workflow-and-state-machines",title:"Combining Laravel Workflow and State Machines",authors:{name:"Richard",title:"Core Team",url:"https://github.com/rmcdaniel",image_url:"https://github.com/rmcdaniel.png",imageURL:"https://github.com/rmcdaniel.png"},tags:["side-effects","random","determinism"]},nextItem:{title:"Introducing Child Workflows in Laravel Workflow",permalink:"/blog/introducing-child-workflows-in-laravel-workflow"}},s={authorsImageUrls:[void 0]},c=[],p={toc:c};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library."),(0,i.kt)("h1",{id:"benefits-of-combining-laravel-workflow-and-state-machines"},"Benefits of Combining Laravel Workflow and State Machines"),(0,i.kt)("p",null,"Using Laravel Workflow and a state machine together provides several advantages:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Flexibility and modularity: Laravel Workflow allows developers to break down complex processes into smaller, modular units that are easy to maintain and update."),(0,i.kt)("li",{parentName:"ol"},"Explicit control over transitions: State machines provide a clear visualization of workflow states, activities, and transitions, making it easier to understand and maintain."),(0,i.kt)("li",{parentName:"ol"},"Robust error handling and retries: Laravel Workflow offers built-in support for handling errors and retries, ensuring that workflows are executed reliably and consistently."),(0,i.kt)("li",{parentName:"ol"},"Scalability: Laravel Workflow supports queuing and parallel execution, allowing workflows to be executed asynchronously on worker servers."),(0,i.kt)("li",{parentName:"ol"},"Integration with Laravel\u2019s queue and event systems: This allows for seamless integration with other Laravel features and packages.")),(0,i.kt)("h1",{id:"installation-guide"},"Installation Guide"),(0,i.kt)("p",null,"To get started with Laravel Workflow and Finite, you will need to install them in your Laravel project:"),(0,i.kt)("p",null,"For Laravel Workflow, run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"composer require laravel-workflow/laravel-workflow\n")),(0,i.kt)("p",null,"For ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/yohang/Finite"},"Finite"),", run the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"composer require yohang/finite\n")),(0,i.kt)("h1",{id:"loan-application-workflow-example"},"Loan Application Workflow Example"),(0,i.kt)("p",null,"The following code demonstrates how to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow")," using Laravel Workflow and Finite:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Finite\\\\StatefulInterface;  \nuse Finite\\\\StateMachine\\\\StateMachine;  \nuse Finite\\\\State\\\\State;  \nuse Finite\\\\State\\\\StateInterface;  \nuse Workflow\\\\Models\\\\StoredWorkflow;  \nuse Workflow\\\\SignalMethod;  \nuse Workflow\\\\WorkflowStub;  \nuse Workflow\\\\Workflow;  \n  \nclass LoanApplicationWorkflow extends Workflow implements StatefulInterface  \n{  \n    private $state;  \n    private $stateMachine;  \n  \n    public function setFiniteState($state)  \n    {  \n        $this->state = $state;  \n    }  \n  \n    public function getFiniteState()  \n    {  \n        return $this->state;  \n    }  \n  \n    #\\[SignalMethod\\]  \n    public function submit()  \n    {  \n        $this->stateMachine->apply('submit');  \n    }  \n  \n    #\\[SignalMethod\\]  \n    public function approve()  \n    {  \n        $this->stateMachine->apply('approve');  \n    }  \n  \n    #\\[SignalMethod\\]  \n    public function deny()  \n    {  \n        $this->stateMachine->apply('deny');  \n    }  \n  \n    public function isSubmitted()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'submitted';  \n    }  \n  \n    public function isApproved()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'approved';  \n    }  \n  \n    public function isDenied()  \n    {  \n        return $this->stateMachine->getCurrentState()->getName() === 'denied';  \n    }  \n  \n    public function \\_\\_construct(  \n        public StoredWorkflow $storedWorkflow,  \n        ...$arguments  \n    ) {  \n        parent::\\_\\_construct($storedWorkflow, $arguments);  \n  \n        $this->stateMachine = new StateMachine();  \n  \n        $this->stateMachine->addState(new State('created', StateInterface::TYPE\\_INITIAL));  \n        $this->stateMachine->addState('submitted');  \n        $this->stateMachine->addState(new State('approved', StateInterface::TYPE\\_FINAL));  \n        $this->stateMachine->addState(new State('denied', StateInterface::TYPE\\_FINAL));  \n  \n        $this->stateMachine->addTransition('submit', 'created', 'submitted');  \n        $this->stateMachine->addTransition('approve', 'submitted', 'approved');  \n        $this->stateMachine->addTransition('deny', 'submitted', 'denied');  \n  \n        $this->stateMachine->setObject($this);  \n        $this->stateMachine->initialize();  \n    }  \n  \n    public function execute()  \n    {  \n        // loan created  \n  \n        yield WorkflowStub::await(fn () => $this->isSubmitted());  \n  \n        // loan submitted  \n  \n        yield WorkflowStub::await(fn () => $this->isApproved() || $this->isDenied());  \n  \n        // loan approved/denied  \n  \n        return $this->stateMachine->getCurrentState()->getName();  \n    }  \n}\n")),(0,i.kt)("p",null,"In this example, we define a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow")," class that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"Workflow")," and implements ",(0,i.kt)("inlineCode",{parentName:"p"},"StatefulInterface"),". The workflow has four states: created, submitted, approved or denied. The workflow transitions between these states by externally calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"submit()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"approve()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"deny()")," signal methods."),(0,i.kt)("p",null,"To use the ",(0,i.kt)("inlineCode",{parentName:"p"},"LoanApplicationWorkflow"),", you can create a new instance of it, start the workflow, submit the loan application, approve it, and get the output as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'// create workflow  \n$workflow = WorkflowStub::make(LoanApplicationWorkflow::class);  \n  \n// start workflow  \n$workflow->start();  \n  \nsleep(1);  \n  \n// submit signal  \n$workflow->submit();  \n  \nsleep(1);  \n  \n// approve signal  \n$workflow->approve();  \n  \nsleep(1);  \n  \n$workflow->output();  \n// "approved"\n')),(0,i.kt)("p",null,"This is the view from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/laravel-workflow/waterline"},"Waterline"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1400/1*m6cOftX9kjBjr6CJGpyQPA.webp",alt:"timeline"})),(0,i.kt)("h1",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Although Laravel Workflow offers a way to define and manage workflows and activities, some developers might still prefer to use a state machine to have more explicit control over the transitions between states or activities."),(0,i.kt)("p",null,"A state machine can provide a more structured and visual representation of the workflow, making it easier to understand and maintain. In such cases, a state machine library can be integrated with Laravel Workflow. This allows developers to define their workflow states, activities, and transitions using the state machine library while still leveraging Laravel Workflow\u2019s features, such as queuing, parallel execution, error handling, retries, and integration with Laravel\u2019s queue and event systems."),(0,i.kt)("p",null,"The Laravel developer community has created several state machine packages that can be integrated with Laravel Workflow, such as the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/yohang/Finite"},"https://github.com/yohang/Finite")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spatie/laravel-model-states"},"https://github.com/spatie/laravel-model-states")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sebdesign/laravel-state-machine"},"https://github.com/sebdesign/laravel-state-machine")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/symfony/workflow"},"https://github.com/symfony/workflow"))),(0,i.kt)("p",null,"By integrating a state machine library with Laravel Workflow, developers can get the best of both worlds: the flexibility and modularity of Laravel Workflow and the explicit control and visualization of a state machine. This can help to create more maintainable, robust, and scalable workflows for complex business processes."))}u.isMDXComponent=!0}}]);