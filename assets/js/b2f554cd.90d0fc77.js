"use strict";(self.webpackChunklaravel_workflow=self.webpackChunklaravel_workflow||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"combining-laravel-workflow-and-state-machines","metadata":{"permalink":"/blog/combining-laravel-workflow-and-state-machines","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md","source":"@site/blog/2023-04-25-combining-laravel-workflow-and-state-machines.md","title":"Combining Laravel Workflow and State Machines","description":"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library.","date":"2023-04-25T00:00:00.000Z","formattedDate":"April 25, 2023","tags":[{"label":"side-effects","permalink":"/blog/tags/side-effects"},{"label":"random","permalink":"/blog/tags/random"},{"label":"determinism","permalink":"/blog/tags/determinism"}],"readingTime":3.665,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"combining-laravel-workflow-and-state-machines","title":"Combining Laravel Workflow and State Machines","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["side-effects","random","determinism"]},"nextItem":{"title":"Introducing Child Workflows in Laravel Workflow","permalink":"/blog/introducing-child-workflows-in-laravel-workflow"}},"content":"When it comes to building web applications, managing complex processes and activities can be a daunting task. Laravel Workflow simplifies this process by providing tools for defining and managing workflows and activities. In addition, integrating a state machine library can offer more explicit control over the transitions between states or activities, resulting in a more structured and visual representation of the workflow. In this blog post, we will explore the benefits of using Laravel Workflow along with a state machine and walk through an example of integrating Laravel Workflow with Finite, a simple state machine library.\\n\\nBenefits of Combining Laravel Workflow and State Machines\\n=========================================================\\n\\nUsing Laravel Workflow and a state machine together provides several advantages:\\n\\n1.  Flexibility and modularity: Laravel Workflow allows developers to break down complex processes into smaller, modular units that are easy to maintain and update.\\n2.  Explicit control over transitions: State machines provide a clear visualization of workflow states, activities, and transitions, making it easier to understand and maintain.\\n3.  Robust error handling and retries: Laravel Workflow offers built-in support for handling errors and retries, ensuring that workflows are executed reliably and consistently.\\n4.  Scalability: Laravel Workflow supports queuing and parallel execution, allowing workflows to be executed asynchronously on worker servers.\\n5.  Integration with Laravel\u2019s queue and event systems: This allows for seamless integration with other Laravel features and packages.\\n\\nInstallation Guide\\n==================\\n\\nTo get started with Laravel Workflow and Finite, you will need to install them in your Laravel project:\\n\\nFor Laravel Workflow, run the following command:\\n\\n```bash\\ncomposer require laravel-workflow/laravel-workflow\\n```\\n\\nFor [Finite](https://github.com/yohang/Finite), run the following command:\\n\\n```bash\\ncomposer require yohang/finite\\n```\\n\\nLoan Application Workflow Example\\n=================================\\n\\nThe following code demonstrates how to create a `LoanApplicationWorkflow` using Laravel Workflow and Finite:\\n\\n```php\\nuse Finite\\\\\\\\StatefulInterface;  \\nuse Finite\\\\\\\\StateMachine\\\\\\\\StateMachine;  \\nuse Finite\\\\\\\\State\\\\\\\\State;  \\nuse Finite\\\\\\\\State\\\\\\\\StateInterface;  \\nuse Workflow\\\\\\\\Models\\\\\\\\StoredWorkflow;  \\nuse Workflow\\\\\\\\SignalMethod;  \\nuse Workflow\\\\\\\\WorkflowStub;  \\nuse Workflow\\\\\\\\Workflow;  \\n  \\nclass LoanApplicationWorkflow extends Workflow implements StatefulInterface  \\n{  \\n    private $state;  \\n    private $stateMachine;  \\n  \\n    public function setFiniteState($state)  \\n    {  \\n        $this->state = $state;  \\n    }  \\n  \\n    public function getFiniteState()  \\n    {  \\n        return $this->state;  \\n    }  \\n  \\n    #\\\\[SignalMethod\\\\]  \\n    public function submit()  \\n    {  \\n        $this->stateMachine->apply(\'submit\');  \\n    }  \\n  \\n    #\\\\[SignalMethod\\\\]  \\n    public function approve()  \\n    {  \\n        $this->stateMachine->apply(\'approve\');  \\n    }  \\n  \\n    #\\\\[SignalMethod\\\\]  \\n    public function deny()  \\n    {  \\n        $this->stateMachine->apply(\'deny\');  \\n    }  \\n  \\n    public function isSubmitted()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'submitted\';  \\n    }  \\n  \\n    public function isApproved()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'approved\';  \\n    }  \\n  \\n    public function isDenied()  \\n    {  \\n        return $this->stateMachine->getCurrentState()->getName() === \'denied\';  \\n    }  \\n  \\n    public function \\\\_\\\\_construct(  \\n        public StoredWorkflow $storedWorkflow,  \\n        ...$arguments  \\n    ) {  \\n        parent::\\\\_\\\\_construct($storedWorkflow, $arguments);  \\n  \\n        $this->stateMachine = new StateMachine();  \\n  \\n        $this->stateMachine->addState(new State(\'created\', StateInterface::TYPE\\\\_INITIAL));  \\n        $this->stateMachine->addState(\'submitted\');  \\n        $this->stateMachine->addState(new State(\'approved\', StateInterface::TYPE\\\\_FINAL));  \\n        $this->stateMachine->addState(new State(\'denied\', StateInterface::TYPE\\\\_FINAL));  \\n  \\n        $this->stateMachine->addTransition(\'submit\', \'created\', \'submitted\');  \\n        $this->stateMachine->addTransition(\'approve\', \'submitted\', \'approved\');  \\n        $this->stateMachine->addTransition(\'deny\', \'submitted\', \'denied\');  \\n  \\n        $this->stateMachine->setObject($this);  \\n        $this->stateMachine->initialize();  \\n    }  \\n  \\n    public function execute()  \\n    {  \\n        // loan created  \\n  \\n        yield WorkflowStub::await(fn () => $this->isSubmitted());  \\n  \\n        // loan submitted  \\n  \\n        yield WorkflowStub::await(fn () => $this->isApproved() || $this->isDenied());  \\n  \\n        // loan approved/denied  \\n  \\n        return $this->stateMachine->getCurrentState()->getName();  \\n    }  \\n}\\n```\\n\\nIn this example, we define a `LoanApplicationWorkflow` class that extends `Workflow` and implements `StatefulInterface`. The workflow has four states: created, submitted, approved or denied. The workflow transitions between these states by externally calling the `submit()`, `approve()`, and `deny()` signal methods.\\n\\nTo use the `LoanApplicationWorkflow`, you can create a new instance of it, start the workflow, submit the loan application, approve it, and get the output as follows:\\n\\n```php\\n// create workflow  \\n$workflow = WorkflowStub::make(LoanApplicationWorkflow::class);  \\n  \\n// start workflow  \\n$workflow->start();  \\n  \\nsleep(1);  \\n  \\n// submit signal  \\n$workflow->submit();  \\n  \\nsleep(1);  \\n  \\n// approve signal  \\n$workflow->approve();  \\n  \\nsleep(1);  \\n  \\n$workflow->output();  \\n// \\"approved\\"\\n```\\n\\nThis is the view from [Waterline](https://github.com/laravel-workflow/waterline).\\n\\n![timeline](https://miro.medium.com/max/1400/1*m6cOftX9kjBjr6CJGpyQPA.webp)\\n\\nConclusion\\n==========\\n\\nAlthough Laravel Workflow offers a way to define and manage workflows and activities, some developers might still prefer to use a state machine to have more explicit control over the transitions between states or activities.\\n\\nA state machine can provide a more structured and visual representation of the workflow, making it easier to understand and maintain. In such cases, a state machine library can be integrated with Laravel Workflow. This allows developers to define their workflow states, activities, and transitions using the state machine library while still leveraging Laravel Workflow\u2019s features, such as queuing, parallel execution, error handling, retries, and integration with Laravel\u2019s queue and event systems.\\n\\nThe Laravel developer community has created several state machine packages that can be integrated with Laravel Workflow, such as the following:\\n\\n- https://github.com/yohang/Finite\\n- https://github.com/spatie/laravel-model-states\\n- https://github.com/sebdesign/laravel-state-machine\\n- https://github.com/symfony/workflow\\n\\nBy integrating a state machine library with Laravel Workflow, developers can get the best of both worlds: the flexibility and modularity of Laravel Workflow and the explicit control and visualization of a state machine. This can help to create more maintainable, robust, and scalable workflows for complex business processes."},{"id":"introducing-child-workflows-in-laravel-workflow","metadata":{"permalink":"/blog/introducing-child-workflows-in-laravel-workflow","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2023-04-05-introducing-child-workflows-in-laravel-workflow.md","source":"@site/blog/2023-04-05-introducing-child-workflows-in-laravel-workflow.md","title":"Introducing Child Workflows in Laravel Workflow","description":"Laravel Workflow has introduced an exciting new feature called \u201cChild Workflows.\u201d This addition aims to enhance the organization and maintainability of complex processes by allowing developers to encapsulate sub-processes within a parent workflow. This article will discuss the benefits of using child workflows, their similarities with running a workflow as an activity, and their compatibility with retry and resume features.","date":"2023-04-05T00:00:00.000Z","formattedDate":"April 5, 2023","tags":[{"label":"child-workflows","permalink":"/blog/tags/child-workflows"},{"label":"nesting","permalink":"/blog/tags/nesting"}],"readingTime":2.35,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"introducing-child-workflows-in-laravel-workflow","title":"Introducing Child Workflows in Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["child-workflows","nesting"]},"prevItem":{"title":"Combining Laravel Workflow and State Machines","permalink":"/blog/combining-laravel-workflow-and-state-machines"},"nextItem":{"title":"New Laravel Workflow Feature: Side Effects","permalink":"/blog/new-laravel-workflow-feature-side-effects"}},"content":"Laravel Workflow has introduced an exciting new feature called \u201cChild Workflows.\u201d This addition aims to enhance the organization and maintainability of complex processes by allowing developers to encapsulate sub-processes within a parent workflow. This article will discuss the benefits of using child workflows, their similarities with running a workflow as an activity, and their compatibility with retry and resume features.\\n\\nWhat are Child Workflows?\\n=========================\\n\\nIn Laravel Workflow, child workflows are a way to manage complex processes by breaking them down into smaller, more manageable units. They enable developers to create hierarchical and modular structures for their workflows, making them more organized and easier to maintain. A child workflow is essentially a separate workflow that is invoked within a parent workflow using the `ChildWorkflowStub::make()` method.\\n\\nBenefits of Using Child Workflows\\n=================================\\n\\n1.  Modularity: Child workflows promote modularity by allowing developers to encapsulate specific functionality within separate, reusable units. This enables better code organization and easier management of complex processes.\\n2.  Reusability: Child workflows can be invoked within multiple parent workflows, which encourages reusability and reduces code duplication.\\n3.  Maintainability: By breaking down complex processes into smaller units, developers can better understand, debug, and maintain their workflows.\\n\\nWorkflows as Activities\\n=======================\\n\\nChild workflows are similar to running a workflow as an activity in that they both encapsulate specific functionality within a parent workflow. However, child workflows offer more flexibility and reusability than activities.\\n\\n![chart](https://miro.medium.com/max/1400/1*pv55DNLlsn7wuNZSL8bXrg.webp)\\n\\nActivities are single-purpose units that perform a specific action within a workflow, such as sending an email or updating a database record. On the other hand, child workflows are complete workflows in themselves, which can be composed of multiple activities and even other child workflows. This allows developers to create complex, nested structures to manage intricate processes more efficiently.\\n\\nRetries and Resumes in Child Workflows\\n======================================\\n\\nChild workflows inherit the same retry and resume features as their parent workflows, enabling developers to manage error handling and recovery more effectively. When a child workflow fails, Laravel Workflow will automatically attempt to retry the failed operation, following the configured retry policy. If the child workflow still fails after all retries have been exhausted, the parent workflow can also be configured to handle the failure accordingly.\\n\\nIn addition, child workflows can be resumed if they are interrupted due to a system failure or crash. This ensures that the entire process can continue from the point of interruption without losing progress or requiring manual intervention.\\n\\nConclusion\\n==========\\n\\nLaravel Workflow\u2019s Child Workflows feature offers developers an effective way to manage complex processes by breaking them down into smaller, more manageable units. This enhances organization, maintainability, and reusability, making it easier for developers to build and maintain intricate workflows. With the added benefits of retry and resume features, child workflows provide a robust and efficient solution for managing complex processes in Laravel applications."},{"id":"new-laravel-workflow-feature-side-effects","metadata":{"permalink":"/blog/new-laravel-workflow-feature-side-effects","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-12-22-new-laravel-workflow-feature-side-effects.md","source":"@site/blog/2022-12-22-new-laravel-workflow-feature-side-effects.md","title":"New Laravel Workflow Feature: Side Effects","description":"effects","date":"2022-12-22T00:00:00.000Z","formattedDate":"December 22, 2022","tags":[{"label":"side-effects","permalink":"/blog/tags/side-effects"},{"label":"random","permalink":"/blog/tags/random"},{"label":"determinism","permalink":"/blog/tags/determinism"}],"readingTime":2.75,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"new-laravel-workflow-feature-side-effects","title":"New Laravel Workflow Feature: Side Effects","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["side-effects","random","determinism"]},"prevItem":{"title":"Introducing Child Workflows in Laravel Workflow","permalink":"/blog/introducing-child-workflows-in-laravel-workflow"},"nextItem":{"title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","permalink":"/blog/job-chaining-vs-fan-out-fan-in"}},"content":"![effects](https://miro.medium.com/max/1400/1*2CEWzQKvYNtpviILF-I-0Q.webp)\\n\\nWorkflows provide a more organized and structured approach to managing distributed processes, making it easier for developers to understand and work with complex logic.\\n\\nLaravel Workflow is a powerful package for the Laravel web framework that provides tools for defining and managing workflows.\\n\\nOne of the key features of any workflow engine is the ability to track the history of a workflow as it is executed which allows a workflow to be retried if it fails or encounters an error. However, this also means that your workflow code must be deterministic and any non-deterministic code has to be carefully managed.\\n\\nRecently, Laravel Workflow added support for [side effects](https://laravel-workflow.com/docs/features/side-effects), which are closures containing non-deterministic code that is only executed once and the result saved. Side effects are a useful way to introduce non-deterministic behavior into a workflow, such as generating a random number or UUID.\\n\\nHere is an example workflow that demonstrates side effects.\\n\\n```php\\nclass SideEffectWorkflow extends Workflow  \\n{  \\n    public function execute()  \\n    {  \\n        $sideEffect = yield WorkflowStub::sideEffect(  \\n          fn () => random\\\\_int(PHP\\\\_INT\\\\_MIN, PHP\\\\_INT\\\\_MAX)  \\n        );  \\n  \\n        $badSideEffect = random\\\\_int(PHP\\\\_INT\\\\_MIN, PHP\\\\_INT\\\\_MAX);  \\n  \\n        $result1 = yield ActivityStub::make(SimpleActivity::class, $sideEffect);  \\n  \\n        $result2 = yield ActivityStub::make(SimpleActivity::class, $badSideEffect);  \\n  \\n        if ($sideEffect !== $result1) {  \\n            throw new Exception(  \\n                \'These side effects should match because it was properly wrapped in WorkflowStub::sideEffect().\'  \\n            );  \\n        }  \\n  \\n        if ($badSideEffect === $result2) {  \\n            throw new Exception(  \\n                \'These side effects should not match because it was not wrapped in WorkflowStub::sideEffect().\'  \\n            );  \\n        }  \\n    }  \\n}\\n```\\n\\nThe activity doesn\u2019t actually do anything. It just takes the input and passes it back out unmodified, so that we can compare the result to what we generated inside of the workflow.\\n\\n```php\\nclass SimpleActivity extends Activity  \\n{  \\n    public function execute($input)  \\n    {  \\n        return $input;  \\n    }  \\n}\\n```\\n\\nIn this example, the workflow generates two random integers: one using a side effect and the other using a local variable. The values of these integers are then passed to two different activities.\\n\\nThe first activity receives the value of the side effect, which has been saved. As a result, the value of the side effect should remain constant throughout the execution of the workflow.\\n\\nThe second activity receives the value of the local variable, which is not saved and will be regenerated. This means that the value of the local variable will change between executions of the workflow.\\n\\nAs a result, it is not expected that the value of the local variable will match the value returned from the second activity. The odds of two random integers generated using `random_int(PHP_INT_MIN, PHP_INT_MAX)` being equal are extremely low, since there are a very large number of possible integers in this range.\\n\\n![dice](https://miro.medium.com/max/1400/1*ElelNBBf4pbE3-nueJcriQ.webp)\\n\\nIt\u2019s important to use side effects appropriately in your workflow to ensure that your workflow is reliable and can recover from failures. Only use side effects for short pieces of code that cannot fail, and make sure to use activities to perform long-running work that may fail and need to be retried, such as API requests or external processes.\\n\\nOverall, side effects are a powerful tool for introducing non-deterministic behavior into your workflows. When used correctly, they can help you to add more flexibility and complexity to your application\u2019s logic.\\n\\nLaravel Workflow is a powerful tool for managing workflows in your Laravel applications, and the addition of support for side effects makes it even more powerful!"},{"id":"job-chaining-vs-fan-out-fan-in","metadata":{"permalink":"/blog/job-chaining-vs-fan-out-fan-in","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-12-06-job-chaining-vs-fan-out-fan-in.md","source":"@site/blog/2022-12-06-job-chaining-vs-fan-out-fan-in.md","title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","description":"Chaining is a workflow design pattern that involves the sequential execution of a series of activities, with the output of one activity potentially serving as the input to the next activity in the chain. This pattern is often used to create a linear, step-by-step process for completing a task.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"chaining","permalink":"/blog/tags/chaining"},{"label":"fan-out","permalink":"/blog/tags/fan-out"},{"label":"fan-in","permalink":"/blog/tags/fan-in"},{"label":"batching","permalink":"/blog/tags/batching"}],"readingTime":2.485,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"job-chaining-vs-fan-out-fan-in","title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["chaining","fan-out","fan-in","batching"]},"prevItem":{"title":"New Laravel Workflow Feature: Side Effects","permalink":"/blog/new-laravel-workflow-feature-side-effects"},"nextItem":{"title":"Waterline: Elegant UI for Laravel Workflows","permalink":"/blog/waterline-ui"}},"content":"[Chaining](https://laravel.com/docs/9.x/queues#job-chaining) is a workflow design pattern that involves the sequential execution of a series of activities, with the output of one activity potentially serving as the input to the next activity in the chain. This pattern is often used to create a linear, step-by-step process for completing a task.\\n\\n![chaining](https://miro.medium.com/max/1400/1*DOzdRnmC8Sq2w509yK1meg.webp)\\n\\nIn contrast, the fan-out/fan-in pattern involves dividing a task into smaller sub-tasks and then combining the results of those sub-tasks to produce the final result. This pattern is often used to parallelize a task and improve its performance by leveraging the power of multiple queue workers.\\n\\n![fan-out/fan-in](https://miro.medium.com/max/1154/1*g-0m-NWockKX_xbWXEjC1A.webp)\\n\\nThere are two phases: fan-out and fan-in.\\n\\nIn the fan-out phase, the workflow divides the main task into smaller sub-tasks and assigns each of those sub-tasks to a different activity. In the fan-in phase, the workflow collects the results of the activities and combines them to produce the final result.\\n\\nThe below workflow represents a simple example of a fan-out/fan-in pattern in which multiple activities are executed in parallel and their results are then merged together.\\n\\nThe workflow divides the task of creating a PDF into activities, with each activity responsible for rendering a single page of the document. Once the individual pages have been rendered, the fan-in phase of the workflow combines the rendered pages into a single PDF document.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass BuildPDFWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        $page1 = ActivityStub::make(ConvertURLActivity::class, \'https://example.com/\');\\n        $page2 = ActivityStub::make(ConvertURLActivity::class, \'https://example.com/\');\\n\\n        $pages = yield ActivityStub::all([$page1, $page2]);\\n\\n        $result = yield ActivityStub::make(MergePDFActivity::class, $pages);\\n\\n        return $result;\\n    }\\n}\\n```\\n\\nThe `ConvertURLActivity` is passed a URL as an argument, and it converts the contents of that URL into a PDF document. Because two separate activities are created, this results in the execution of two instances of `ConvertURLActivity` in parallel.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertURLActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        $fileName = uniqid() . \'.pdf\';\\n\\n        Http::withHeaders([\\n            \'Apikey\' => \'YOUR-API-KEY-GOES-HERE\',\\n        ])\\n        ->withOptions([\\n            \'sink\' => storage_path($fileName),\\n        ])\\n        ->post(\'https://api.cloudmersive.com/convert/web/url/to/pdf\', [\\n            \'Url\' => $url,\\n        ]);\\n\\n        return $fileName;\\n    }\\n}\\n```\\n\\nNext, the `BuildPDFWorkflow` uses `ActivityStub::all` to wait for both `ConvertURLActivity` instances to complete. This is an example of the fan-in part of the fan-out/fan-in pattern, as it collects the results of the parallel activities and combines them into a single array of PDF files.\\n\\nFinally, the `BuildPDFWorkflow` executes the`MergePDFActivity`, which is passed the array of PDFs that were generated by the `ConvertURLActivity` instances, and merges them into a single PDF document.\\n\\n```php\\nnamespace App\\\\Workflows\\\\BuildPDF;\\n\\nuse setasign\\\\Fpdi\\\\Fpdi;\\nuse Workflow\\\\Activity;\\n\\nclass MergePDFActivity extends Activity\\n{\\n    public function execute($pages)\\n    {\\n        $fileName = uniqid() . \'.pdf\';\\n\\n        $pdf = new Fpdi();\\n\\n        foreach ($pages as $page) {\\n            $pdf->AddPage();\\n            $pdf->setSourceFile(storage_path($page));\\n            $pdf->useTemplate($pdf->importPage(1));\\n        }\\n\\n        $pdf->Output(\'F\', storage_path($fileName));\\n\\n        foreach ($pages as $page) {\\n            unlink(storage_path($page));\\n        }\\n\\n        return $fileName;\\n    }\\n}\\n```\\n\\nThis is what the final PDF looks like\u2026\\n\\n![merged PDF](https://miro.medium.com/max/1400/1*A3PKGEk8JptFIxB9IqCh6w.webp)\\n\\nOverall, using the fan-out/fan-in pattern in this way can significantly reduce the time it takes to create a PDF document, making the process more efficient and scalable.\\n\\nThanks for reading!"},{"id":"waterline-ui","metadata":{"permalink":"/blog/waterline-ui","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-19-waterline-ui.md","source":"@site/blog/2022-11-19-waterline-ui.md","title":"Waterline: Elegant UI for Laravel Workflows","description":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!","date":"2022-11-19T00:00:00.000Z","formattedDate":"November 19, 2022","tags":[{"label":"ui","permalink":"/blog/tags/ui"},{"label":"horizon","permalink":"/blog/tags/horizon"},{"label":"queues","permalink":"/blog/tags/queues"},{"label":"workflows","permalink":"/blog/tags/workflows"}],"readingTime":1.45,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"waterline-ui","title":"Waterline: Elegant UI for Laravel Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["ui","horizon","queues","workflows"]},"prevItem":{"title":"Laravel Workflow: Job Chaining vs. Fan-out/Fan-in","permalink":"/blog/job-chaining-vs-fan-out-fan-in"},"nextItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"}},"content":"One of the pros to using workflows is that it makes monitoring easy. Using Waterline makes it even easier!\\n\\n![dashboard](https://miro.medium.com/max/1400/1*2FP4crjpM8C48kAnqAjv5A.webp)\\n\\nLook familiar? Yes, this is shamelessly based on Horizon! However, the similarity is only superficial. Waterline is geared towards workflows, not queues. In fact, Horizon is still the best way to monitor your queues and plays along nicely with it.\\n\\n> Waterline is to workflows what Horizon is to queues.\\n\\n![workflow view](https://miro.medium.com/max/1400/1*EKWNNFy6kYRrqMbaozA8IQ.webp)\\n\\nAt this point you can see a lot of differences! You can see the arguments passed to the workflow and the output from the completed workflow. You can see a timeline that shows each activity at a glance along with any exceptions that were thrown. There is also a list view for the activities and their results.\\n\\nAt the bottom are any exceptions thrown, including a stack trace and a snippet of code showing the exact line. This makes debugging a breeze.\\n\\nIf you\u2019re familiar with Horizon then installing Waterline will be like d\xe9j\xe0 vu but the setup is simpler because Waterline doesn\u2019t care about queues, only workflows.\\n\\n## Installation\\n\\nYou can find the official [documentation](https://github.com/laravel-workflow/waterline) here but setup is simple.\\n\\n```bash\\ncomposer require laravel-workflow/waterline  \\n  \\nphp artisan waterline:publish\\n```\\n\\nThat\u2019s it! Now you should be able to view the `/waterline` URL in your app. By default this URL is only available in local environments. To view this outside of local environments you will have to modify the `WaterlineServiceProvider`.\\n\\n```php\\nGate::define(\'viewWaterline\', function ($user) {  \\n    return in_array($user->email, [  \\n        \'admin@example.com\',  \\n    ]);  \\n});\\n```\\n\\nThis will allow only the single admin user to access the Waterline UI.\\n\\nIf you want more context for the workflow that is show in the screenshot above, make sure to read my [previous article](https://medium.com/@laravel-workflow/email-verifications-using-laravel-workflow-acd6707aa7b3).\\n\\nThanks for reading!"},{"id":"invalidating-cloud-images","metadata":{"permalink":"/blog/invalidating-cloud-images","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-11-15-invalidating-cloud-images.md","source":"@site/blog/2022-11-15-invalidating-cloud-images.md","title":"Invalidating Cloud Images in Laravel with Workflows","description":"Many services like Cloud Image offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.","date":"2022-11-15T00:00:00.000Z","formattedDate":"November 15, 2022","tags":[{"label":"cache","permalink":"/blog/tags/cache"},{"label":"invalidation","permalink":"/blog/tags/invalidation"},{"label":"cloud","permalink":"/blog/tags/cloud"},{"label":"images","permalink":"/blog/tags/images"}],"readingTime":2.875,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"invalidating-cloud-images","title":"Invalidating Cloud Images in Laravel with Workflows","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["cache","invalidation","cloud","images"]},"prevItem":{"title":"Waterline: Elegant UI for Laravel Workflows","permalink":"/blog/waterline-ui"},"nextItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"Many services like [Cloud Image](https://docs.cloudimage.io/go/cloudimage-documentation-v7/en/caching-acceleration/invalidation-api) offer a way to invalidate cached images so that they are pulled from your server again. This is useful if you have updated the source image on your server and want future requests to use the latest copy.\\n\\nHowever, it can be challenging if you want to automate this and also ensure that the image has been invalidated. This is because most invalidation APIs are asynchronous. When you request an image to be cleared from the cache, the API will return a response immediately. Then the actual process to clear the image from the cache runs in the background, sometimes taking up to 30 seconds before the image is updated. You could simply trust that the process works but it is also possible to be 100% sure with an automated workflow.\\n\\nThe workflow we need to write is as follows:\\n\\n1.  Check the currently cached image\u2019s timestamp via HEAD call\\n2.  Invalidate cached image via API call\\n3.  Check if the image timestamp has changed\\n4.  If not, wait a while and check again\\n5.  After 3 failed checks, go back to step 2\\n\\nThe workflow consists of two activities. The first activity gets the current timestamp of the image. This timestamp is used to determine if the image was actually cleared from the cache or not.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass CheckImageDateActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        return Http::head(\'https://\' . config(\'services.cloudimage.token\') . \'.cloudimg.io/\' . $url)\\n            ->header(\'date\');\\n    }\\n}\\n```\\n\\nThe second activity makes the actual call to Cloud Image\u2019s API to invalidate the image from the cache.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Http;\\nuse Workflow\\\\Activity;\\n\\nclass InvalidateCacheActivity extends Activity\\n{\\n    public function execute($url)\\n    {\\n        Http::withHeaders([\\n            \'X-Client-key\' => config(\'services.cloudimage.key\'),\\n            \'Content-Type\' => \'application/json\'\\n        ])->post(\'https://api.cloudimage.com/invalidate\', [\\n            \'scope\' => \'original\',\\n            \'urls\' => [\\n                \'/\' . $url\\n            ],\\n        ]);\\n    }\\n}\\n```\\n\\nThe workflow looks as follows and is the same process as outlined before.\\n\\n```php\\nnamespace App\\\\Workflows\\\\InvalidateCache;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass InvalidateCacheWorkflow extends Workflow\\n{\\n    public function execute($url)\\n    {\\n        $oldDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n        while (true) {\\n            yield ActivityStub::make(InvalidateCacheActivity::class, $url);\\n\\n            for ($i = 0; $i < 3; ++$i) { \\n                yield WorkflowStub::timer(30);\\n\\n                $newDate = yield ActivityStub::make(CheckImageDateActivity::class, $url);\\n\\n                if ($oldDate !== $newDate) return;    \\n            }\\n        }\\n    }\\n}\\n```\\n\\nLine 13 uses an activity to get the current timestamp of the image we want to invalidate from the cache.\\n\\nLine 15 starts a loop that only exits when the image timestamp has changed.\\n\\nLine 16 uses an activity to invalidate the image from the cache.\\n\\nLine 18 starts a loop that tries a maximum of three times to first sleep and then check if the image timestamp has change, after three times the loop restarts at line 15.\\n\\nLine 19 sleeps the workflow for 30 seconds. This gives Cloud Image time to clear the image from their cache before checking the timestamp again.\\n\\nLines 21\u201323 reuse the activity from earlier to get the current timestamp of the cached image and compare it to the one saved on line 13. If the timestamps don\u2019t match then the image has successfully been cleared from the cache and we can exit the workflow. Otherwise, after three attempts, we start the process over again.\\n\\nThis is how the workflow execution looks in the queue assuming no retries are needed.\\n\\n![workflow execution](https://miro.medium.com/max/1400/1*7psZLD9mKGJnzEw508oIAw.webp)\\n\\nThe added benefit is that your image is now cached again and will be fast for the next user! Thanks for reading!"},{"id":"converting-videos-with-ffmpeg","metadata":{"permalink":"/blog/converting-videos-with-ffmpeg","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-31-converting-videos-with-ffmpeg.md","source":"@site/blog/2022-10-31-converting-videos-with-ffmpeg.md","title":"Converting Videos with FFmpeg and Laravel Workflow","description":"FFmpeg is a free, open-source software project allowing you to record, convert and stream audio and video.","date":"2022-10-31T00:00:00.000Z","formattedDate":"October 31, 2022","tags":[{"label":"video","permalink":"/blog/tags/video"},{"label":"ffmpeg","permalink":"/blog/tags/ffmpeg"},{"label":"conversion","permalink":"/blog/tags/conversion"},{"label":"transcoding","permalink":"/blog/tags/transcoding"}],"readingTime":1.67,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"converting-videos-with-ffmpeg","title":"Converting Videos with FFmpeg and Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["video","ffmpeg","conversion","transcoding"]},"prevItem":{"title":"Invalidating Cloud Images in Laravel with Workflows","permalink":"/blog/invalidating-cloud-images"},"nextItem":{"title":"Email Verifications Using Laravel Workflow","permalink":"/blog/email-verifications"}},"content":"[FFmpeg](https://ffmpeg.org/) is a free, open-source software project allowing you to record, convert and stream audio and video.\\n\\n[Laravel Queues](https://laravel.com/docs/9.x/queues) are great for long running tasks. Converting video takes a long time! With [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow), you can harness the power of queues to convert videos in the background and easily manage the process.\\n\\nRequirements\\n============\\n\\n1.  You\u2019ll need to [install FFmpeg](https://ffmpeg.org/download.html)\\n2.  Then `composer require php-ffmpeg/php-ffmpeg` ([docs](https://github.com/PHP-FFMpeg/PHP-FFMpeg#readme))\\n3.  Finally `composer require laravel-workflow/laravel-workflow` ([docs](https://github.com/laravel-workflow/laravel-workflow#laravel-workflow-))\\n\\nWorkflow\\n========\\n\\nA workflow is an easy way to orchestrate activities. A workflow that converts a video from one format to another might have several activities, such as downloading the video from storage, the actual conversion, and then finally notifying the user that it\u2019s finished.\\n\\nFor simplicity, the workflow we are making today will only contain the most interesting activity, converting the video.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\Workflow;\\n\\nclass ConvertVideoWorkflow extends Workflow\\n{\\n    public function execute()\\n    {\\n        yield ActivityStub::make(\\n            ConvertVideoWebmActivity::class,\\n            storage_path(\'app/oceans.mp4\'),\\n            storage_path(\'app/oceans.webm\'),\\n        );\\n    }\\n}\\n```\\n\\nWe need a video to convert. We can use this one:\\n\\n[http://vjs.zencdn.net/v/oceans.mp4](http://vjs.zencdn.net/v/oceans.mp4)\\n\\nDownload it and save it to your app storage folder.\\n\\n```php\\nnamespace App\\\\Workflows\\\\ConvertVideo;\\n\\nuse FFMpeg\\\\FFMpeg;\\nuse FFMpeg\\\\Format\\\\Video\\\\WebM;\\nuse Workflow\\\\Activity;\\n\\nclass ConvertVideoWebmActivity extends Activity\\n{\\n    public $timeout = 5;\\n\\n    public function execute($input, $output)\\n    {\\n        $ffmpeg = FFMpeg::create();\\n        $video = $ffmpeg->open($input);\\n        $format = new WebM();\\n        $format->on(\'progress\', fn () => $this->heartbeat());\\n        $video->save($format, $output);\\n    }\\n}\\n```\\n\\nThe activity converts any input video into a [WebM](https://www.webmproject.org/) output video. While ffmpeg is converting the video, a progress callback is triggered which in turn heartbeats the activity.\\n\\nThis is necessary because we have set a reasonable timeout of 5 seconds but we also have no idea how long it will take to convert the video. As long as we send a heartbeat at least once every 5 seconds, the activity will not timeout.\\n\\n![heartbeat](https://miro.medium.com/max/1400/1*ccrxeOEZYQciDYEprRKWiQ.webp)\\n\\n![no heartbeat](https://miro.medium.com/max/1400/1*9ZF3LTqjf4qsVcNVX5LK0A.webp)\\n\\nWithout a heartbeat, the worker will be killed after the timeout of 5 seconds is reached.\\n\\nTo actually run the workflow you just need to call:\\n\\n```php\\nWorkflowStub::make(ConvertVideoWorkflow::class)->start();\\n```\\n\\nAnd that\u2019s it!"},{"id":"email-verifications","metadata":{"permalink":"/blog/email-verifications","editUrl":"https://github.com/laravel-workflow/laravel-workflow.github.io/edit/main/blog/2022-10-29-email-verifications.md","source":"@site/blog/2022-10-29-email-verifications.md","title":"Email Verifications Using Laravel Workflow","description":"A typical registration process goes as follows:","date":"2022-10-29T00:00:00.000Z","formattedDate":"October 29, 2022","tags":[{"label":"emails","permalink":"/blog/tags/emails"},{"label":"verification","permalink":"/blog/tags/verification"},{"label":"signed-urls","permalink":"/blog/tags/signed-urls"}],"readingTime":4.42,"hasTruncateMarker":false,"authors":[{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"}],"frontMatter":{"slug":"email-verifications","title":"Email Verifications Using Laravel Workflow","authors":{"name":"Richard","title":"Core Team","url":"https://github.com/rmcdaniel","image_url":"https://github.com/rmcdaniel.png","imageURL":"https://github.com/rmcdaniel.png"},"tags":["emails","verification","signed-urls"]},"prevItem":{"title":"Converting Videos with FFmpeg and Laravel Workflow","permalink":"/blog/converting-videos-with-ffmpeg"}},"content":"A typical registration process goes as follows:\\n\\n1.  User fills out registration form and submits it\\n2.  Laravel creates user in database with null `email_verified_at`\\n3.  Laravel sends email with a code, or a link back to our website\\n4.  User enters code, or clicks link\\n5.  Laravel sets `email_verified_at` to the current time\\n\\nWhat\u2019s wrong with this? Nothing. But like all things, as soon as real world complexity creeps in, this pattern could become painful. What if you wanted to send an email after the code or link expires? And do you really need a user in your database if they never verify their email address?\\n\\nLet\u2019s take this trivial example and replace it with a workflow. This is based on the [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library.\\n\\nGet Started\\n===========\\n\\nCreate a standard Laravel application and create the following files. First, the API routes.\\n\\n```php\\nuse App\\\\Workflows\\\\VerifyEmail\\\\VerifyEmailWorkflow;\\nuse Illuminate\\\\Support\\\\Facades\\\\Hash;\\nuse Illuminate\\\\Support\\\\Facades\\\\Route;\\nuse Workflow\\\\WorkflowStub;\\n\\nRoute::get(\'/register\', function () {\\n    $workflow = WorkflowStub::make(VerifyEmailWorkflow::class);\\n\\n    $workflow->start(\\n        \'test+1@example.com\',\\n        Hash::make(\'password\'),\\n    );\\n\\n    return response()->json([\\n        \'workflow_id\' => $workflow->id(),\\n    ]);\\n});\\n\\nRoute::get(\'/verify-email\', function () {\\n    $workflow = WorkflowStub::load(request(\'workflow_id\'));\\n\\n    $workflow->verify();\\n\\n    return response()->json(\'ok\');\\n})->name(\'verify-email\');\\n```\\n\\nThe `register` route creates a new `VerifyEmailWorkflow` , passes in the email and password, and then starts the workflow. Notice that we hash the password before giving it to the workflow. This prevents the plain text from being stored in the workflow logs.\\n\\nThe `verify-email` route receives a workflow id, loads it and then calls the `verify()` signal method.\\n\\nNow let\u2019s take a look at the actual workflow.\\n\\n```php\\nuse Workflow\\\\ActivityStub;\\nuse Workflow\\\\SignalMethod;\\nuse Workflow\\\\Workflow;\\nuse Workflow\\\\WorkflowStub;\\n\\nclass VerifyEmailWorkflow extends Workflow\\n{\\n    private bool $verified = false;\\n\\n    #[SignalMethod]\\n    public function verify()\\n    {\\n        $this->verified = true;\\n    }\\n\\n    public function execute($email = \'\', $password = \'\')\\n    {\\n        yield ActivityStub::make(SendEmailVerificationEmailActivity::class, $email);\\n\\n        yield WorkflowStub::await(fn () => $this->verified);\\n\\n        yield ActivityStub::make(VerifyEmailActivity::class, $email, $password);\\n    }\\n}\\n```\\n\\nTake notice of the `yield` keywords. Because PHP (and most other languages) cannot save their execution state, coroutines rather than normal functions are used inside of workflows (but not activities). A coroutine will be called multiple times in order to execute to completion.\\n\\n![graph](https://miro.medium.com/max/1400/1*6eE2Gll61IbAAU85Md75OQ.webp)\\n\\nEven though this workflow will execute to completion effectively once, it will still be partially executed four different times. The results of activities are cached so that only failed activities will be called again. Successful activities get skipped.\\n\\nBut notice that any code we write between these calls will be called multiple times. That\u2019s why your code needs to be **deterministic** inside of workflow methods! If your code has four executions, each at different times, they must still all behave the same. There are no such limitations within activity methods.\\n\\nStep By Step\\n============\\n\\nThe first time the workflow executes, it will reach the call to `SendEmailVerificationEmailActivity` , start that activity, and then exit. Workflows suspend execution while an activity is running. After the `SendEmailVerificationEmailActivity` finishes, it will resume execution of the workflow. This brings us to\u2026\\n\\nThe second time the workflow is executed, it will reach the call to `SendEmailVerificationEmailActivity` and skip it because it will already have the result of that activity. Then it will reach the call to `WorkflowStub::await()` which allows the workflow to wait for an external signal. In this case, it will come from the user clicking on the verification link they receive in their email. Once the workflow is signaled then it will execute for\u2026\\n\\nThe third time, both the calls to `SendEmailVerificationEmailActivity` and `WorkflowStub::await()` are skipped. This means that the `VerifyEmailActivity` will be started. After the final activity has executed we still have\u2026\\n\\nThe final time the workflow is called, there is nothing left to do so the workflow completes.\\n\\nNow let\u2019s take a look at the activities.\\n\\nThe first activity just sends the user an email.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Mail\\\\VerifyEmail;\\nuse Illuminate\\\\Support\\\\Facades\\\\Mail;\\nuse Workflow\\\\Activity;\\n\\nclass SendEmailVerificationEmailActivity extends Activity\\n{\\n    public function execute($email)\\n    {\\n        Mail::to($email)->send(new VerifyEmail($this->workflowId()));\\n    }\\n}\\n```\\n\\nThe email contains a temporary signed URL that includes the workflow ID.\\n\\n```php\\nnamespace App\\\\Mail;\\n\\nuse Illuminate\\\\Bus\\\\Queueable;\\nuse Illuminate\\\\Mail\\\\Mailable;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Content;\\nuse Illuminate\\\\Mail\\\\Mailables\\\\Envelope;\\nuse Illuminate\\\\Queue\\\\SerializesModels;\\nuse Illuminate\\\\Support\\\\Facades\\\\URL;\\n\\nclass VerifyEmail extends Mailable\\n{\\n    use Queueable, SerializesModels;\\n\\n    private $workflowId;\\n\\n    public function __construct($workflowId)\\n    {\\n        $this->workflowId = $workflowId;\\n    }\\n\\n    public function envelope()\\n    {\\n        return new Envelope(\\n            subject: \'Verify Email\',\\n        );\\n    }\\n\\n    public function content()\\n    {\\n        return new Content(\\n            view: \'emails.verify-email\',\\n            with: [\\n                \'url\' => URL::temporarySignedRoute(\\n                    \'verify-email\',\\n                    now()->addMinutes(30),\\n                    [\'workflow_id\' => $this->workflowId],\\n                ),\\n            ],\\n        );\\n    }\\n\\n    public function attachments()\\n    {\\n        return [];\\n    }\\n}\\n```\\n\\nThe user gets the URL in a clickable link.\\n\\n```\\n<a href=\\"{{ $url }}\\">verification link</a>\\n```\\n\\nThis link takes the user to the `verify-email` route from our API routes, which will then start the final activity.\\n\\n```php\\nnamespace App\\\\Workflows\\\\VerifyEmail;\\n\\nuse App\\\\Models\\\\User;\\nuse Workflow\\\\Activity;\\n\\nclass VerifyEmailActivity extends Activity\\n{\\n    public function execute($email, $password)\\n    {\\n        $user = new User();\\n        $user->name = \'\';\\n        $user->email = $email;\\n        $user->email_verified_at = now();\\n        $user->password = $password;\\n        $user->save();\\n    }\\n}\\n```\\n\\nWe have created the user and verified their email address at the same time. Neat!\\n\\nWrapping Up\\n===========\\n\\nIf we take a look at the output of `php artisan queue:work` we can better see how the workflow and individual activities are interleaved.\\n\\n![queue worker](https://miro.medium.com/max/1400/1*q6-r41SN-uWfzp6p7Z4r8g.webp)\\n\\nWe can see the four different executions of the workflow, the individual activities and the signal we sent.\\n\\nThe [Laravel Workflow](https://github.com/laravel-workflow/laravel-workflow) library is heavily inspired by [Temporal](https://temporal.io/) but powered by [Laravel Queues](https://laravel.com/docs/9.x/queues).\\n\\nThanks for reading!"}]}')}}]);